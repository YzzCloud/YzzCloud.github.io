<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NETCONF与YANG编程</title>
    <url>/2023/10/18/NETCONF%E4%B8%8EYANG%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>介绍：</p>
<p>NETCONF协议是一种网络设备管理协议，类似SNMP，提供一套新增、修 改、删除网络设备配置，查询配置、状态和统计信息的框架机制。</p>
<p>YANG是数据模型定义语言，可以用来描述基于NETCONF协议通信的客户 端和服务器之间的交互模型，类似SNMP使用MIB文件作为数据模型。</p>
<span id="more"></span>

<h1 id="NETCONF与YANG编程"><a href="#NETCONF与YANG编程" class="headerlink" title="NETCONF与YANG编程"></a>NETCONF与YANG编程</h1><h1 id="实现自动化必要的趋势"><a href="#实现自动化必要的趋势" class="headerlink" title="实现自动化必要的趋势"></a>实现自动化必要的趋势</h1><h2 id="缩短部署时间"><a href="#缩短部署时间" class="headerlink" title="缩短部署时间"></a>缩短部署时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">自动化可以帮助减少部署时间。可编程性有助于快速验证新的功能、部署新的服务并且立即升级路由器。这要求网络设备具有一致和完整的应用编程接口(API)，最终目标是使网络运维工作中所有可以自动化的工作全部自动化。</span><br></pre></td></tr></table></figure>



<h2 id="CLI无法作为标准"><a href="#CLI无法作为标准" class="headerlink" title="CLI无法作为标准"></a>CLI无法作为标准</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">虽然CLI不是API，但不幸的是不得不将其视为一个API，因为必须长期依赖它。然而，使用CLI进行自动化既不可靠，也不具有成本效益。</span><br><span class="line">首先，许多与服务相关的配置更改会涉及一个以上的设备，配置更改变得越来越复杂</span><br><span class="line">其次，虽然CLI是人性化的，但却不适合自动化，原因如下：</span><br><span class="line"><span class="number">1.</span>CLI没有标准化。虽然网络设备配置CLI是相似的，但从语法和语义的角度来看，不同厂商或特定厂商的操作系统并不一致。</span><br><span class="line"><span class="number">2.</span>通过CLI配置设备时存在依赖性问题。某些情况下，配置VLAN之前必须输入用于配置接口的CLI命令。如果这些步骤未按正确的顺序执行，则配置失败，或者更糟糕的是，配置仅部分完成</span><br><span class="line"><span class="number">3.</span>CLI只提供有限的错误报告，还不能以易于使用的脚本格方式报告错误</span><br><span class="line"><span class="number">4.</span>CLI不产生任何结构化的输出。因此，从display命令中提取信息的唯一方法是通过“屏幕抓取”，或使用正则表达式模式匹配从输出中提取数据。最后，<span class="string">&quot;display命令&quot;</span>经常更改以显示更多功能、更多计数器等。问题是即使对display命令</span><br><span class="line">进行更小的更改（例如在输出中添加空格）也可能会破坏对于特定值的提取</span><br><span class="line"><span class="number">5.</span>必须清楚设备的特征，例如用telnet登录必须匹配到某段字符串，然而你在真正了解此型号的设备之前，是无法预知会出现怎样的显示信息的</span><br><span class="line"><span class="number">6.</span>依赖命令行限制了网络的发展，例如害怕升级设备会导致自动化脚本的中断，所以推迟或不去部署必要的安全补丁。而这种升级的恐惧也解释了以数据模型来作为驱动的自动化速度很缓慢</span><br></pre></td></tr></table></figure>



<h2 id="硬件与软件的解耦"><a href="#硬件与软件的解耦" class="headerlink" title="硬件与软件的解耦"></a>硬件与软件的解耦</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">行业越来越倾向于将软件和硬件进行分离，最终目标是将白盒组装成统一的硬件，以Linux为操作系统，并针对不同网络功能使用特定的应用程序---可能从一个供应商购买BGP功能，从另一个供应商购买OSPF协议，再从第三个供应商购买RADIUS和管理功能。这样做的优势显而易见：</span><br><span class="line"><span class="number">1.</span>全部使用Linux模糊了服务器和网络管理之间的界限，并降低了支持成本。不仅“路由器”和“交换机”都在Linux上运行，Linux环境还提供了许多工具和应用程序，包括管理操作</span><br><span class="line"><span class="number">2.</span>使用Linux意味着更广泛的共识：人们直接从学校开始接受更好的培训。在硬件商品化的情况下联网不再困难，因为厂商的CLI不是唯一的。换句话说，不同的设备厂商在CLI方面不再竞争。更多的不再需要专门懂某个厂商设备的人，而转向具有linux和脚本技能的人选。因此，高级网络工程师应该少关注厂商的具体内容，多关注更广泛的网络架构和技术基础。而对于厂商来说，除了关注认证以及部分基于CLI的知识，还应该更加关注独立于CLI之外的网络编程和操作方面的内容</span><br><span class="line"><span class="number">3.</span>在网络中使用相同的硬件，而不是特殊的专用硬件，可以降低网络的复杂性（缺点是硬件bug会影响到所有平台）</span><br><span class="line"><span class="number">4.</span>网络和服务工程师可以专注于面向业务的任务，而不仅仅是网络运营和维护。网络开始成为业务的推动者，而业务和网络之间的链接正是软件。随着自动化所节约的时间，工程师将成为推动网络创新以满足业务需求的关键推动力</span><br></pre></td></tr></table></figure>



<h2 id="数据模型驱动的管理"><a href="#数据模型驱动的管理" class="headerlink" title="数据模型驱动的管理"></a>数据模型驱动的管理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">良好的脚本需要基于良好的API</span><br><span class="line"><span class="number">1.</span>可编程API应该抽象化底层实现的复杂性。Devops工程师不需要知道不必要的详细信息，例如网元的特定配置顺序，或者在发生故障时需要采取的具体步骤。如果上述信息对人类来说不直观，那么配置引擎的命令排序就会更加复杂。配置的功能应该更像是填写高级检查清单（这些是你需要的设置；现在系统可以确定如何正确分组和排序）</span><br><span class="line"><span class="number">2.</span>API关键工作（无论是软件API还是网络API）是为数据提供规格。首先，它回答了数据是什么的问题----整数、字符串或其他类型的值？接下来，它指定了该数据的组织方式。在传统编程中这被称为数据结构，在网络可编程性和数据库的世界中更常见的术语是架构，也称为数据模型</span><br><span class="line"><span class="number">3.</span>访问数据的方法：API需要为如何读取和操作数据提供标准化的框架</span><br><span class="line"><span class="number">4.</span>将API应用于复杂的环境时，关键是供应商以基于标准的方式实施API。不同设备和供应商之间定义和访问数据应该有一种通用方法，运维人员不必为网络中的每个不同设备和功能学习单独的专有接口</span><br></pre></td></tr></table></figure>



<h1 id="案例1：使用netconf配置日志主机位"><a href="#案例1：使用netconf配置日志主机位" class="headerlink" title="案例1：使用netconf配置日志主机位"></a>案例1：使用netconf配置日志主机位</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ncclient.xml_ <span class="keyword">import</span> to_ele</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ncclient  模块  很多东西都补全不了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">netconf</span>():</span><br><span class="line">    <span class="keyword">return</span> manager.connect(host=<span class="string">&quot;192.168.100.1&quot;</span>,</span><br><span class="line">                           port=<span class="number">830</span>,</span><br><span class="line">                           username=<span class="string">&quot;netconf&quot;</span>,</span><br><span class="line">                           password=<span class="string">&quot;Huawei12#$&quot;</span>,</span><br><span class="line">                           look_for_keys=<span class="literal">False</span>,</span><br><span class="line">                           allow_agent=<span class="literal">False</span>,</span><br><span class="line">                           hostkey_verify=<span class="literal">False</span>,</span><br><span class="line">                           device_params=&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;huawei&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    CONFIG = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;edit-config&gt;</span></span><br><span class="line"><span class="string">    &lt;target&gt;</span></span><br><span class="line"><span class="string">      &lt;running/&gt;</span></span><br><span class="line"><span class="string">    &lt;/target&gt;</span></span><br><span class="line"><span class="string">    &lt;default-operation&gt;merge&lt;/default-operation&gt;</span></span><br><span class="line"><span class="string">    &lt;error-option&gt;rollback-on-error&lt;/error-option&gt;</span></span><br><span class="line"><span class="string">    &lt;config&gt;</span></span><br><span class="line"><span class="string">      &lt;syslog xmlns=&quot;http://www.huawei.com/netconf/vrp&quot; content-version=&quot;1.0&quot; format-version=&quot;1.0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;syslogServers&gt;</span></span><br><span class="line"><span class="string">          &lt;syslogServer operation=&quot;merge&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;ipType&gt;ipv4&lt;/ipType&gt;</span></span><br><span class="line"><span class="string">            &lt;serverIp&gt;10.1.60.2&lt;/serverIp&gt;</span></span><br><span class="line"><span class="string">            &lt;isDefaultVpn&gt;false&lt;/isDefaultVpn&gt;</span></span><br><span class="line"><span class="string">            &lt;vrfName&gt;_public_&lt;/vrfName&gt;</span></span><br><span class="line"><span class="string">            &lt;timestamp&gt;UTC&lt;/timestamp&gt;</span></span><br><span class="line"><span class="string">            &lt;transportMode&gt;tcp&lt;/transportMode&gt;</span></span><br><span class="line"><span class="string">          &lt;/syslogServer&gt;</span></span><br><span class="line"><span class="string">        &lt;/syslogServers&gt;</span></span><br><span class="line"><span class="string">      &lt;/syslog&gt;</span></span><br><span class="line"><span class="string">    &lt;/config&gt;</span></span><br><span class="line"><span class="string">  &lt;/edit-config&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        m = netconf()</span><br><span class="line">        <span class="comment"># 将字符串转换成XML文件对象</span></span><br><span class="line">        content = to_ele(CONFIG)</span><br><span class="line">        res = m.rpc(content)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&lt;ok/&gt;&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(res):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;execute successfully&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;execute fail&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<h2 id="使用Netconf查询日志主机位"><a href="#使用Netconf查询日志主机位" class="headerlink" title="使用Netconf查询日志主机位"></a>使用Netconf查询日志主机位</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> manager</span><br><span class="line"><span class="keyword">from</span> ncclient.xml_ <span class="keyword">import</span> to_ele</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ncclient  模块  很多东西都补全不了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">netconf</span>():</span><br><span class="line">    <span class="keyword">return</span> manager.connect(host=<span class="string">&quot;192.168.100.1&quot;</span>,</span><br><span class="line">                           port=<span class="number">830</span>,</span><br><span class="line">                           username=<span class="string">&quot;netconf&quot;</span>,</span><br><span class="line">                           password=<span class="string">&quot;Huawei12#$&quot;</span>,</span><br><span class="line">                           look_for_keys=<span class="literal">False</span>,</span><br><span class="line">                           allow_agent=<span class="literal">False</span>,</span><br><span class="line">                           hostkey_verify=<span class="literal">False</span>,</span><br><span class="line">                           device_params=&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;huawei&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    CONFIG = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  &lt;get&gt;</span></span><br><span class="line"><span class="string">    &lt;filter type=&quot;subtree&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;syslog xmlns=&quot;http://www.huawei.com/netconf/vrp&quot; content-version=&quot;1.0&quot; format-version=&quot;1.0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;syslogServers&gt;</span></span><br><span class="line"><span class="string">          &lt;syslogServer&gt;</span></span><br><span class="line"><span class="string">            &lt;ipType&gt;&lt;/ipType&gt;</span></span><br><span class="line"><span class="string">            &lt;serverIp&gt;&lt;/serverIp&gt;</span></span><br><span class="line"><span class="string">            &lt;isDefaultVpn&gt;&lt;/isDefaultVpn&gt;</span></span><br><span class="line"><span class="string">            &lt;vrfName&gt;&lt;/vrfName&gt;</span></span><br><span class="line"><span class="string">            &lt;timestamp&gt;&lt;/timestamp&gt;</span></span><br><span class="line"><span class="string">            &lt;transportMode&gt;&lt;/transportMode&gt;</span></span><br><span class="line"><span class="string">            &lt;sslPolicyName&gt;&lt;/sslPolicyName&gt;</span></span><br><span class="line"><span class="string">            &lt;isBriefFmt&gt;&lt;/isBriefFmt&gt;</span></span><br><span class="line"><span class="string">          &lt;/syslogServer&gt;</span></span><br><span class="line"><span class="string">        &lt;/syslogServers&gt;</span></span><br><span class="line"><span class="string">      &lt;/syslog&gt;</span></span><br><span class="line"><span class="string">    &lt;/filter&gt;</span></span><br><span class="line"><span class="string">  &lt;/get&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">    m = netconf()</span><br><span class="line">    <span class="comment"># 将字符串转换成XML文件对象</span></span><br><span class="line">    content = to_ele(CONFIG)</span><br><span class="line">    res = m.rpc(content)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    m.close()</span><br></pre></td></tr></table></figure>



<h2 id="netconf-配置-vlan"><a href="#netconf-配置-vlan" class="headerlink" title="#netconf 配置 vlan"></a>#netconf 配置 vlan</h2><p>以下预先在CE配置ssh</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> manager</span><br><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> operations</span><br><span class="line"></span><br><span class="line">CREATE_VLAN = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;config&gt;</span></span><br><span class="line"><span class="string">      &lt;vlan xmlns=&quot;http://www.huawei.com/netconf/vrp&quot; content-version=&quot;1.0&quot; format-version=&quot;1.0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;vlans&gt;</span></span><br><span class="line"><span class="string">          &lt;vlan operation=&quot;merge&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;vlanId&gt;10&lt;/vlanId&gt;</span></span><br><span class="line"><span class="string">            &lt;vlanName&gt;VLAN10&lt;/vlanName&gt;</span></span><br><span class="line"><span class="string">            &lt;vlanType&gt;common&lt;/vlanType&gt;</span></span><br><span class="line"><span class="string">          &lt;/vlan&gt;</span></span><br><span class="line"><span class="string">        &lt;/vlans&gt;</span></span><br><span class="line"><span class="string">      &lt;/vlan&gt;</span></span><br><span class="line"><span class="string">    &lt;/config&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">netconf_manager</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    <span class="keyword">return</span> manager.connect(</span><br><span class="line">        host=ip,</span><br><span class="line">        port=port,</span><br><span class="line">        username=username,</span><br><span class="line">        password=password,</span><br><span class="line">        look_for_keys=<span class="literal">False</span>,</span><br><span class="line">        allow_agent=<span class="literal">False</span>,</span><br><span class="line">        hostkey_verify=<span class="literal">False</span>,</span><br><span class="line">        device_params=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;huawei&#x27;</span>&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_response</span>(<span class="params">rpc_obj, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;RPCReplay for <span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;rpc_obj.xml&#125;</span>&#x27;</span>)</span><br><span class="line">    xml_str = rpc_obj.xml</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&lt;ok/&gt;&#x27;</span> <span class="keyword">in</span> xml_str:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> successfully&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Cannot successfully excute: <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_edit</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    <span class="keyword">with</span> netconf_manager(ip, port, username, password) <span class="keyword">as</span> m:</span><br><span class="line">        rpc_obj = m.edit_config(target=<span class="string">&#x27;running&#x27;</span>, config=CREATE_VLAN)</span><br><span class="line">        check_response(rpc_obj, CREATE_VLAN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_edit(<span class="string">&#x27;192.168.56.200&#x27;</span>, <span class="number">830</span>, <span class="string">&#x27;netconf&#x27;</span>, <span class="string">&#x27;Huawei12#$&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">-----------------------------------</span><br><span class="line">F:\Python\Python310\python.exe C:\Users\admin\Desktop\MyStudySpace\project\devops\ncclient_t.py </span><br><span class="line">RPCReplay <span class="keyword">for</span> </span><br><span class="line">&lt;config&gt;</span><br><span class="line">      &lt;vlan xmlns=<span class="string">&quot;http://www.huawei.com/netconf/vrp&quot;</span> content-version=<span class="string">&quot;1.0&quot;</span> <span class="built_in">format</span>-version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">        &lt;vlans&gt;</span><br><span class="line">          &lt;vlan operation=<span class="string">&quot;merge&quot;</span>&gt;</span><br><span class="line">            &lt;vlanId&gt;<span class="number">10</span>&lt;/vlanId&gt;</span><br><span class="line">            &lt;vlanName&gt;VLAN10&lt;/vlanName&gt;</span><br><span class="line">            &lt;vlanType&gt;common&lt;/vlanType&gt;</span><br><span class="line">          &lt;/vlan&gt;</span><br><span class="line">        &lt;/vlans&gt;</span><br><span class="line">      &lt;/vlan&gt;</span><br><span class="line">    &lt;/config&gt;</span><br><span class="line"> <span class="keyword">is</span> &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;rpc-reply message-<span class="built_in">id</span>=<span class="string">&quot;urn:uuid:fd908a16-c192-4eab-98d2-9caa6d2bc108&quot;</span> xmlns=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span> flow-<span class="built_in">id</span>=<span class="string">&quot;37&quot;</span>&gt;</span><br><span class="line">  &lt;ok/&gt;</span><br><span class="line">&lt;/rpc-reply&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;config&gt;</span><br><span class="line">      &lt;vlan xmlns=<span class="string">&quot;http://www.huawei.com/netconf/vrp&quot;</span> content-version=<span class="string">&quot;1.0&quot;</span> <span class="built_in">format</span>-version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">        &lt;vlans&gt;</span><br><span class="line">          &lt;vlan operation=<span class="string">&quot;merge&quot;</span>&gt;</span><br><span class="line">            &lt;vlanId&gt;<span class="number">10</span>&lt;/vlanId&gt;</span><br><span class="line">            &lt;vlanName&gt;VLAN10&lt;/vlanName&gt;</span><br><span class="line">            &lt;vlanType&gt;common&lt;/vlanType&gt;</span><br><span class="line">          &lt;/vlan&gt;</span><br><span class="line">        &lt;/vlans&gt;</span><br><span class="line">      &lt;/vlan&gt;</span><br><span class="line">    &lt;/config&gt;</span><br><span class="line"> successfully</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>NETCONF</tag>
        <tag>YANG</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack基础命令行管理</title>
    <url>/2023/10/24/OpenStack%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Description：</p>
<p>openstack有些功能只能使用命令行来实现，通过命令行界面返回结果更快，操作效率很高，像创建镜像比较耗时的操作，使用命令行更加合适。命令行提供的命令还可以在脚本中使用，以实现批处理操作，提高工作效率。</p>
<p>常见的管理由创建、删除等。</p>
<span id="more"></span>

<h1 id="命令行管理-openstack"><a href="#命令行管理-openstack" class="headerlink" title="命令行管理 openstack"></a>命令行管理 openstack</h1><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">====================================[user]====================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看云主机</span></span><br><span class="line">[root@controller ~ (user)]$ openstack server list </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除云主机</span></span><br><span class="line">[root@controller ~ (user)]$ openstack server delete  &lt;server&gt; </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看卷</span></span><br><span class="line">[root@controller ~ (user)]$ openstack volume list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除卷</span></span><br><span class="line">[root@controller ~ (user)]$ openstack volume delete &lt;vloume&gt; </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看路由器</span></span><br><span class="line"> [root@controller ~ (user)]$ openstack router list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看子网</span></span><br><span class="line">[root@controller ~ (user)]$ openstack subnet list </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除路由网关 <span class="comment">#使用子网来删除路由网关</span></span></span><br><span class="line">[root@controller ~ (user)]$ openstack router remove subnet &lt;router&gt; &lt;subnet&gt;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看VPC/网络</span></span><br><span class="line">[root@controller ~ (user)]$ openstack network list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看VPC下的subnet/子网</span></span><br><span class="line">[root@controller ~ (user)]$ openstack subnet list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除subnet/子网</span></span><br><span class="line">[root@controller ~ (user)]$ openstack subnet delete &lt;subnet&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除VPC/网络</span></span><br><span class="line">[root@controller ~ (user)]$ openstack network delete &lt;network&gt; </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看浮动ip</span></span><br><span class="line">[root@controller ~ (user)]$ openstack floating ip list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除浮动ip</span></span><br><span class="line">[root@controller ~ (user)]$ openstack floating ip delete &lt;floating ip&gt;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看安全组</span></span><br><span class="line">[root@controller ~ (user)]$ openstack security group list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除安全组</span></span><br><span class="line">[root@controller ~ (user)]$ openstack security group delete  &lt;group&gt; </span><br><span class="line"></span><br><span class="line">====================================[user]====================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================[admin]====================================</span><br><span class="line">[admin]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看用户</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack user list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除用户</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack user delete &lt;user&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看角色</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack role list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除角色</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack role delete &lt;role&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看项目/租户</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack project list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除项目/租户</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack project delete &lt;project&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看规格</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack flavor list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除规格</span></span><br><span class="line">[root@controller ~ (admin)]$openstack flavor delete &lt;flavor&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看镜像</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack image list </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取消镜像保护/删除镜像</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack image set --unprotected &lt;image&gt;</span><br><span class="line">[root@controller ~ (admin)]$ openstack image delete &lt;image&gt;</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除外部网关  和删除路由接口命令有区别</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack router unset --external-gateway &lt;router&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除路由</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack router delete  &lt;router&gt;</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除subnet/子网</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack subnet delete &lt;subnet&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除VPC/网络</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack network delete &lt;network&gt;</span><br><span class="line"></span><br><span class="line">====================================[admin]====================================</span><br></pre></td></tr></table></figure>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">====================================[admin]====================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建项目/租户</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack project  create  &lt;project&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建角色</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack role create &lt;role&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建用户</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack user create --project &lt;project&gt; --password-prompt &lt;user&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户关联项目以及角色    <span class="comment">#三关联</span></span></span><br><span class="line">[root@controller ~ (admin)]$ openstack role add --project &lt;project&gt; --user &lt;user&gt; &lt;role&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建规格</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack flavor create --vcpus 1 --ram 1024 --disk 10  &lt;flavor&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建镜像</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack image create --file ./cirros-0.4.0-x86_64-disk.img --disk-format qcow2 --container-format bare --min-disk 5 --min-ram 512 --public &lt;image&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置镜像保护</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack image set --protected &lt;image&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建外部网络</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack network create --project &lt;project&gt;  --provider-network-type flat --provider-physical-network provider --external --share &lt;network&gt; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建subnet/子网</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack subnet create --network &lt;network&gt; --subnet-range 221.106.10.0/24 --gateway 221.106.10.1 --dhcp --allocation-pool start=221.106.10.200,end=221.106.10.210 --dns-nameserver 114.114.114.114 &lt;subnet&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建路由</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack router create --project &lt;project&gt; &lt;router&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置外部路由网关</span></span><br><span class="line">[root@controller ~ (admin)]$ openstack router set --external-gateway &lt;network&gt; &lt;router&gt;</span><br><span class="line">====================================[admin]====================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================[user]=====================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建VPC/网络</span></span><br><span class="line">[root@controller ~ (user)]$ openstack network create &lt;network&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建subnet/子网</span></span><br><span class="line">[root@controller ~ (user)]$ openstack subnet create --network  &lt;network&gt;  --subnet-range 192.168.12.0/24 --gateway 192.168.12.1 --dhcp --allocation-pool start=192.168.12.2,end=192.168.12.100 --dns-nameserver 114.114.114.114  &lt;subnet&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置路由网关</span></span><br><span class="line">[root@controller ~ (user)]$ openstack router add subnet &lt;router&gt; &lt;subnet&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建安全组</span></span><br><span class="line">[root@controller ~ (user)]$ openstack security group create &lt;name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加入方向规则</span></span><br><span class="line">[root@controller ~ (user)]$ openstack security group rule create --protocol icmp --ingress &lt;security group&gt;</span><br><span class="line">[root@controller ~ (user)]$ openstack security group rule create --protocol tcp --dst-port 22 --ingress &lt;security group&gt;</span><br><span class="line">[root@controller ~ (user)]$ openstack security group rule create --protocol tcp --dst-port 80 --ingress &lt;security group&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建云主机</span></span><br><span class="line">[root@controller ~ (user)]$ openstack server create --flavor &lt;flavor&gt; --image &lt;image&gt; --network &lt;network&gt; --security-group &lt;security group&gt; &lt;name&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">申请弹性ip&amp;绑定弹性ip</span></span><br><span class="line">[root@controller ~ (user)]$ openstack floating ip create &lt;network&gt;</span><br><span class="line">[root@controller ~ (user)]$ openstack server add floating ip &lt;server&gt; &lt;floating ip&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建卷</span></span><br><span class="line">[root@controller ~ (user)]$ openstack volume create --size 5 &lt;name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">绑定卷</span></span><br><span class="line">[root@controller ~ (user)]$ openstack server add volume &lt;server&gt; &lt;volume&gt;</span><br><span class="line"></span><br><span class="line">====================================[user]=====================================</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2023/10/18/RabbitMQ/</url>
    <content><![CDATA[<p>介绍：RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue 高级消息队列协议 ）的开源实现，由于erlang 语言的高并发特性，性能较好，本质是个队列，FIFO 先入先出，里面存放的内容是message。</p>
<p>RabbitMQ 是一个消息中间件：它接收消息并且转发，就类似于一个快递站，卖家把快递通过快递站，送到我们的手上，MQ也是这样，接收并存储消息，再转发。</p>
<span id="more"></span>


<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">erlang-21.3.8.9-1.el7.x86_64.rpm  rabbitmq-server-3.8.1-1.el7.noarch.rpm  tengine-2.3.2.tar.gz</span><br><span class="line">[root@py ~]<span class="comment"># yum install erlang-21.3.8.9-1.el7.x86_64.rpm rabbitmq-server-3.8.1-1.el7.noarch.rpm</span></span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  erlang.x86_64 0:21.3.8.9-1.el7                  rabbitmq-server.noarch 0:3.8.1-1.el7</span><br><span class="line"></span><br><span class="line">Dependency Installed:</span><br><span class="line">  socat.x86_64 0:1.7.3.2-2.el7</span><br><span class="line"></span><br><span class="line">15672 客户端web</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><img src="image-20230925174414515.png" alt="image-20230925174414515"></p>
<h3 id="工作特性"><a href="#工作特性" class="headerlink" title="工作特性"></a>工作特性</h3><p><img src="image-20230925174453467.png" alt="image-20230925174453467"></p>
<h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@py ~]<span class="comment"># rabbitmq</span></span><br><span class="line">rabbitmqctl           rabbitmq-plugins      rabbitmq-server</span><br><span class="line">rabbitmq-diagnostics  rabbitmq-queues       rabbitmq-upgrade</span><br><span class="line">[root@py ~]<span class="comment"># ss -tanl</span></span><br><span class="line">State       Recv-Q Send-Q      Local Address:Port                     Peer Address:Port</span><br><span class="line">LISTEN      0      50                      *:3306                                *:*</span><br><span class="line">LISTEN      0      128                     *:6379                                *:*</span><br><span class="line">LISTEN      0      128                     *:22                                  *:*</span><br><span class="line">LISTEN      0      100             127.0.0.1:25                                  *:*</span><br><span class="line">LISTEN      0      128                    :::22                                 :::*</span><br><span class="line">LISTEN      0      128                    :::3000                               :::*</span><br><span class="line">LISTEN      0      100                   ::1:25                                 :::*</span><br><span class="line">[root@py ~]<span class="comment"># rabbitmq-plugins list</span></span><br><span class="line"></span><br><span class="line">[root@py ~]<span class="comment"># rabbitmq-plugins enable rabbitmq_management</span></span><br><span class="line">Enabling plugins on node rabbit@py:</span><br><span class="line">rabbitmq_management</span><br><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@py...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@py ~]<span class="comment"># systemctl start rabbitmq-server</span></span><br><span class="line">[root@py ~]<span class="comment"># ps -ef |grep rabbit</span></span><br><span class="line">rabbitmq  10262      1  0 17:25 ?     </span><br><span class="line">[root@py ~]<span class="comment"># ss -tanl |grep 5672</span></span><br><span class="line">LISTEN     0      128          *:25672                    *:*</span><br><span class="line">LISTEN     0      128          *:15672                    *:*</span><br><span class="line">LISTEN     0      128         :::5672                    :::*</span><br></pre></td></tr></table></figure>

<p><img src="image-20230925174852367.png" alt="image-20230925174852367"></p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@py ~]<span class="comment"># rabbitmqctl add_user cloud cloud</span></span><br><span class="line">Adding user <span class="string">&quot;cloud&quot;</span> ...</span><br><span class="line">[root@py ~]<span class="comment"># rabbitmq</span></span><br><span class="line">rabbitmqctl           rabbitmq-plugins      rabbitmq-server</span><br><span class="line">rabbitmq-diagnostics  rabbitmq-queues       rabbitmq-upgrade</span><br><span class="line">[root@py ~]<span class="comment"># rabbitmqctl list_users</span></span><br><span class="line">Listing <span class="built_in">users</span> ...</span><br><span class="line">user    tags</span><br><span class="line">cloud   []</span><br><span class="line">guest   [administrator]</span><br><span class="line">[root@py ~]<span class="comment"># rabbitmqctl set_user_tags cloud administrator</span></span><br><span class="line">Setting tags <span class="keyword">for</span> user <span class="string">&quot;cloud&quot;</span> to [administrator] ...</span><br><span class="line">[root@py ~]<span class="comment"># rabbitmqctl list_users</span></span><br><span class="line">Listing <span class="built_in">users</span> ...</span><br><span class="line">user    tags</span><br><span class="line">cloud   [administrator]</span><br><span class="line">guest   [administrator]</span><br><span class="line">[root@py ~]<span class="comment"># rabbitmqctl change_password cloud newpassword</span></span><br><span class="line">[root@py ~]<span class="comment"># rabbitmqctl delete_user cloud </span></span><br></pre></td></tr></table></figure>



<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p><img src="image-20230925175148206.png" alt="image-20230925175148206"></p>
<h2 id="virtual-host"><a href="#virtual-host" class="headerlink" title="virtual host"></a>virtual host</h2><blockquote>
<p>交换机和queue的组合</p>
</blockquote>
<p><img src="image-20230925173719204.png" alt="image-20230925173719204"></p>
<h2 id="PiKa库"><a href="#PiKa库" class="headerlink" title="&#x3D;&#x3D;PiKa库&#x3D;&#x3D;"></a>&#x3D;&#x3D;PiKa库&#x3D;&#x3D;</h2><blockquote>
<p>Pika是纯Python实现的支持AMQP协议的库</p>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><img src="image-20230925181821184.png" alt="image-20230925181821184"></p>
<blockquote>
<p>The default exchange is implicitly bound to every queue, with a routing key equal to the queue name. It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.</p>
</blockquote>
<p><img src="image-20230925182134978.png" alt="image-20230925182134978"></p>
<p>测试get message</p>
<p><img src="image-20230925182545661.png" alt="image-20230925182545661"></p>
<p><img src="image-20230925182637358.png" alt="image-20230925182637358"></p>
<h2 id="RR"><a href="#RR" class="headerlink" title="&#x3D;&#x3D;RR&#x3D;&#x3D;"></a>&#x3D;&#x3D;RR&#x3D;&#x3D;</h2><p>&#x3D;&#x3D;Round-robin dispatching&#x3D;&#x3D;</p>
<p><img src="image-20230925201458485.png" alt="image-20230925201458485"></p>
<p><img src="image-20230925202311723.png" alt="image-20230925202311723"></p>
<ul>
<li>●queue. _declare声明- 个queue,有必要的话，创建它。</li>
<li>●basic. _publish exchange为空就使用缺省exchange,如果找不到指定的exchange,抛异常</li>
<li>使用缺省exchange,就必须指定routing _key,使用它找到queue</li>
</ul>
<p><img src="image-20230925202411777.png" alt="image-20230925202411777"></p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">from</span> pika.credentials <span class="keyword">import</span> PlainCredentials</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 指定虚拟主机 通过交换机路由 声明queue并创建 通过此队列进行通信</span></span><br><span class="line"><span class="comment"># 缺省交换机（不指定就是默认）连接每一个queue直接指定到test/queue</span></span><br><span class="line"><span class="comment"># 消费者通过queue去拿，消费者自己也可以创建queue</span></span><br><span class="line"><span class="comment"># 生产者和消费者通过中间件进行解耦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sender</span></span><br><span class="line"><span class="comment"># param = pika.ConnectionParameters(</span></span><br><span class="line"><span class="comment">#     &#x27;192.168.24.157&#x27;, port=5672,</span></span><br><span class="line"><span class="comment">#     virtual_host=&#x27;test&#x27;,</span></span><br><span class="line"><span class="comment">#     credentials=PlainCredentials(&#x27;cloud&#x27;, &#x27;cloud&#x27;)</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"><span class="comment"># 声明 如果不存在 立即创建  queue的持久化 连接断了数据没了 queue会survive  durable=True</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)  <span class="comment"># 生产端声明 不存在 直接创建</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>,  <span class="comment"># 交换机 不指定 默认缺省  test/default</span></span><br><span class="line">                          routing_key=<span class="string">&#x27;hello&#x27;</span>,  <span class="comment"># queue的名字</span></span><br><span class="line">                          body=<span class="string">&#x27;data-&#123;:2&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>



<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"><span class="comment"># 声明 如果不存在 立即创建</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费端直接去queue里拿</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] Received <span class="subst">&#123;body&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># def callback1(ch, method, properties, body):</span></span><br><span class="line"><span class="comment">#     print(f&quot; [y] Received &#123;body&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                      auto_ack=<span class="literal">True</span>,</span><br><span class="line">                      on_message_callback=callback)</span><br><span class="line"><span class="comment"># channel.basic_consume(queue=&#x27;hello&#x27;,</span></span><br><span class="line"><span class="comment">#                       auto_ack=True,</span></span><br><span class="line"><span class="comment">#                       on_message_callback=callback1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()  <span class="comment"># 产生阻塞 有就去消费</span></span><br></pre></td></tr></table></figure>



<h2 id="应答"><a href="#应答" class="headerlink" title="应答"></a>应答</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">消息队列一般需要缓冲成千上万条消息,队列中消息只有一份，只能给一个消费者处理。消费者读取一个消息后，需要给RabbitMQ Server一个确认(acknowledgement)JI ，然后RabbitMQ才会删除它。</span><br><span class="line">默认basic_consume中auto_ack为False,也就是需要手动确认收到了，不会自动回应。</span><br></pre></td></tr></table></figure>

<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">交换机、队列都不会持久化，如需持久化需要未交换机、队列设置durable为<span class="literal">True</span>。</span><br><span class="line">消息持久化，需要队列首先持久化，然后生产者发布消息时增加持久化属性。</span><br><span class="line"></span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>,  <span class="comment"># 交换机 不指定 默认缺省  test/default</span></span><br><span class="line">                          routing_key=<span class="string">&#x27;hello&#x27;</span>,  <span class="comment"># queue的名字</span></span><br><span class="line">                          <span class="comment">#  # 持久化数据 队列必须持久化</span></span><br><span class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>),</span><br><span class="line">                          body=<span class="string">&#x27;data-&#123;:2&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">特别注意，持久化不能保证百分之百消息不丢失,如果数据在缓存中，还未真正写入磁盘,数据还是有部分丢失的风险。</span><br></pre></td></tr></table></figure>

<h2 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">上面的轮询方式，不管消费者是否空闲还是繁忙，只是看似公平的分发,但其实Server没有关注消费者未确认消息数。</span><br><span class="line"></span><br><span class="line">使用basic_qos(prefetch_count=1)来解决,该方法告诉RabbitMQ不要一直给消费者发多条消息， 如果消费者为确认上一条消息， 就不要给它发了，发给别的不忙的消费者。</span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line"><span class="comment"># 在这种情况下，将prefetch_count设置为1意味着消费者每次只会预取一条消息。这样做的目的是确保消费者在处理完当前消息之前不会预取更多的消息。这种设置可以帮助实现公平分发，确保每个消费者都能平均地处理消息，而不会出现某个消费者一次性获取过多的消息而导致其他消费者无法及时处理的情况。通过调用channel.basic_qos(prefetch_count=1)，您可以确保每个消费者在处理完当前消息之前只会预取一条消息，从而实现更均衡的消息处理。</span></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                      auto_ack=False,   <span class="comment"># 取消自动应答</span></span><br><span class="line">                      on_message_callback=callback)</span><br></pre></td></tr></table></figure>



<h2 id="发布、订阅模式"><a href="#发布、订阅模式" class="headerlink" title="发布、订阅模式"></a>发布、订阅模式</h2><p>&#x3D;&#x3D;如果exchange是fanout,也就是广播了，routing_ key就无所谓是什么了。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;尝试先启动生产者,再启动消费者试试看。<br>部分数据丢失，因为，exchange收到了数据， 没有queue接收,所以，exchange丢弃 了这些数据。&#x3D;&#x3D;</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Publish/Subscribe发布和订阅，想象一下订阅报纸， 所有订阅者(消费者)订阅这个报纸(消息) ,都应该拿到一份同样内容的报纸。订阅者和消费者之间还有一个exchange,可以想象成邮局，消费者去邮局订阅报纸，报社发报纸到邮局，邮局决定如何投递到消费者手中。</span><br><span class="line"></span><br><span class="line">上例中工作队列模式的使用，相当于，每个人只能拿到不同的报纸。所以，不适用发布订阅模式。</span><br><span class="line"></span><br><span class="line">当前模式的exchange的<span class="built_in">type</span>是fanout,就是一对多，即广播模式。</span><br><span class="line">注意,同一个queue的消息只能被消费一次, 所以,这里使用了多个queue,相当于为了保证不同的消费者拿到同样的数据，每一个消费者都应该有自 己的queue.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="image-20230925212517591.png" alt="image-20230925212517591"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line">ex_name = <span class="string">&#x27;logs&#x27;</span>                <span class="comment"># 绑定</span></span><br><span class="line">ex_type = <span class="string">&#x27;fanout&#x27;</span></span><br><span class="line">q_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">channel.exchange_declare(exchange=ex_name,</span><br><span class="line">                         exchange_type=ex_type)</span><br><span class="line"><span class="comment"># 声明 如果不存在 立即创建  queue的持久化 连接断了数据没了 queue会survive  durable=True</span></span><br><span class="line"><span class="comment"># channel.queue_declare(queue=&#x27;hello&#x27;)  # 生产端声明 不存在 直接创建</span></span><br><span class="line"><span class="comment"># 消息持久化     1.队列持久化 2.改变消息的属性值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    channel.basic_publish(exchange=ex_name,  <span class="comment"># 交换机 不指定 默认缺省  test/default</span></span><br><span class="line">                          routing_key=<span class="string">&#x27;&#x27;</span>,  <span class="comment"># queue的名字</span></span><br><span class="line">                          <span class="comment">#  # 持久化数据 队列必须持久化</span></span><br><span class="line">                          <span class="comment"># properties=pika.BasicProperties(delivery_mode=2),</span></span><br><span class="line">                          body=<span class="string">&#x27;data-&#123;:2&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">connection.close()</span><br><span class="line">======================================================================================================</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">from</span> pika.adapters.blocking_connection <span class="keyword">import</span> BlockingChannel</span><br><span class="line"></span><br><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel: BlockingChannel = connection.channel()</span><br><span class="line">ex_name = <span class="string">&#x27;logs&#x27;</span>  <span class="comment"># 绑定</span></span><br><span class="line">ex_type = <span class="string">&#x27;fanout&#x27;</span></span><br><span class="line">channel.exchange_declare(exchange=ex_name,</span><br><span class="line">                         exchange_type=ex_type)</span><br><span class="line"></span><br><span class="line">result1 = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)  <span class="comment"># queue连接断开就消亡</span></span><br><span class="line">q_name1 = result1.method.queue</span><br><span class="line">channel.queue_bind(exchange=ex_name, queue=q_name1)</span><br><span class="line"></span><br><span class="line">result2 = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)  <span class="comment"># queue连接断开就消亡</span></span><br><span class="line">q_name2 = result2.method.queue</span><br><span class="line">channel.queue_bind(exchange=ex_name, queue=q_name2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费端直接去queue里拿</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    ctag = method.consumer_tag</span><br><span class="line">    dtag = method.delivery_tag</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;|&#123;&#125; ** &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ctag, dtag, body))</span><br><span class="line">    channel.basic_ack(dtag)  <span class="comment"># 手动应答</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = channel.basic_consume(queue=q_name1,</span><br><span class="line">                           auto_ack=<span class="literal">False</span>,  <span class="comment"># 取消自动应答</span></span><br><span class="line">                           on_message_callback=callback)</span><br><span class="line">c2 = channel.basic_consume(queue=q_name2,</span><br><span class="line">                           auto_ack=<span class="literal">False</span>,  <span class="comment"># 取消自动应答</span></span><br><span class="line">                           on_message_callback=callback)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()  <span class="comment"># 产生阻塞 有就去消费</span></span><br><span class="line">connection.close()</span><br><span class="line"></span><br><span class="line">======================================================================================================</span><br><span class="line">ctag1<span class="number">.8711</span>e677a4a74ca289ac87677ac8914f|<span class="number">1</span> ** <span class="string">b&#x27;data-22&#x27;</span></span><br><span class="line">ctag1.e908371606cd45c28a656f64046b5ab1|<span class="number">2</span> ** <span class="string">b&#x27;data-22&#x27;</span></span><br><span class="line">ctag1<span class="number">.8711</span>e677a4a74ca289ac87677ac8914f|<span class="number">3</span> ** <span class="string">b&#x27;data-23&#x27;</span></span><br><span class="line">ctag1.e908371606cd45c28a656f64046b5ab1|<span class="number">4</span> ** <span class="string">b&#x27;data-23&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>路由Routing</p>
<p><img src="image-20230926175836507.png" alt="image-20230926175836507"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line">ex_name = <span class="string">&#x27;colors&#x27;</span>                <span class="comment"># 绑定</span></span><br><span class="line">ex_type = <span class="string">&#x27;direct&#x27;</span></span><br><span class="line">q_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">colors = (<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">channel.exchange_declare(exchange=ex_name,</span><br><span class="line">                         exchange_type=ex_type)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    rk = random.choice(colors)  <span class="comment"># routing-key</span></span><br><span class="line">    channel.basic_publish(exchange=ex_name,  <span class="comment"># 交换机 不指定 默认缺省  test/default</span></span><br><span class="line">                          routing_key=rk,  <span class="comment"># queue的名字</span></span><br><span class="line">                          body=<span class="string">&#x27;&#123;&#125;-data-&#123;:2&#125;&#x27;</span>.<span class="built_in">format</span>(rk, i))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line">connection.close()</span><br><span class="line"></span><br><span class="line">===============================================================================================================</span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">from</span> pika.adapters.blocking_connection <span class="keyword">import</span> BlockingChannel</span><br><span class="line"></span><br><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel: BlockingChannel = connection.channel()</span><br><span class="line">ex_name = <span class="string">&#x27;colors&#x27;</span>                <span class="comment"># 绑定</span></span><br><span class="line">ex_type = <span class="string">&#x27;direct&#x27;</span></span><br><span class="line">colors = (<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">channel.exchange_declare(exchange=ex_name, exchange_type=ex_type)</span><br><span class="line">result1 = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)  <span class="comment"># queue连接断开就消亡</span></span><br><span class="line">q_name1 = result1.method.queue</span><br><span class="line"><span class="comment"># channel.queue_bind(exchange=ex_name, routing_key=colors[0], queue=q_name1)</span></span><br><span class="line">channel.queue_bind(q_name1, ex_name, colors[<span class="number">0</span>])</span><br><span class="line">result2 = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)  <span class="comment"># queue连接断开就消亡</span></span><br><span class="line">q_name2 = result2.method.queue</span><br><span class="line"><span class="comment"># channel.queue_bind(exchange=ex_name, queue=q_name2)</span></span><br><span class="line">channel.queue_bind(q_name2, ex_name, colors[<span class="number">1</span>])</span><br><span class="line">channel.queue_bind(q_name2, ex_name, colors[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费端直接去queue里拿</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    ctag = method.consumer_tag</span><br><span class="line">    dtag = method.delivery_tag</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;|&#123;&#125; ** &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ctag, dtag, body))</span><br><span class="line">    <span class="comment"># channel.basic_ack(dtag)  # 手动应答</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = channel.basic_consume(queue=q_name1,</span><br><span class="line">                           auto_ack=<span class="literal">True</span>,  <span class="comment"># 取消自动应答</span></span><br><span class="line">                           on_message_callback=callback)</span><br><span class="line">c2 = channel.basic_consume(queue=q_name2,</span><br><span class="line">                           auto_ack=<span class="literal">True</span>,  <span class="comment"># 取消自动应答</span></span><br><span class="line">                           on_message_callback=callback)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()  <span class="comment"># 产生阻塞 有就去消费</span></span><br><span class="line">connection.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="image-20230926184929261.png" alt="image-20230926184929261"></p>
<p><img src="image-20230926185442309.png" alt="image-20230926185442309"></p>
<h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><blockquote>
<p>支持模式匹配而已</p>
<p>routine_key 必须使用  .点号分割的单词组成</p>
</blockquote>
<p>支持使用通配符：</p>
<ul>
<li>*    表示样的一个单词</li>
<li>#   表示0个或者多个单词</li>
<li>如果queue绑定的routing key只是一个#， 这个queue其实可以接收所有的消息。</li>
<li>如果没有使用任何通配符，效果类似于direct,因为只能和字符匹配了。</li>
</ul>
<p><img src="image-20230926185733828.png" alt="image-20230926185733828"></p>
<img src="image-20230926190851077.png" alt="image-20230926190851077" style="zoom:150%;">

<img src="image-20230926190904821.png" alt="image-20230926190904821" style="zoom:150%;">

<p><img src="image-20230926191034741.png" alt="image-20230926191034741"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line">ex_name = <span class="string">&#x27;products&#x27;</span>  <span class="comment"># 绑定</span></span><br><span class="line">ex_type = <span class="string">&#x27;topic&#x27;</span></span><br><span class="line">q_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">products = (<span class="string">&#x27;pc&#x27;</span>, <span class="string">&#x27;phone&#x27;</span>, <span class="string">&#x27;tv&#x27;</span>)</span><br><span class="line">colors = (<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">channel.exchange_declare(exchange=ex_name, exchange_type=ex_type)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    rk = <span class="string">&quot;&#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        random.choice(products),</span><br><span class="line">        random.choice(colors)</span><br><span class="line">    )</span><br><span class="line">    msg = <span class="string">&#x27;&#123;&#125;-data- &#123;:2&#125;&#x27;</span>.<span class="built_in">format</span>(rk, i)</span><br><span class="line">    channel.basic_publish(exchange=ex_name,  <span class="comment"># 交换机 不指定 默认缺省  test/default</span></span><br><span class="line">                          routing_key=rk,  <span class="comment"># queue的名字</span></span><br><span class="line">                          <span class="comment">#  # 持久化数据 队列必须持久化</span></span><br><span class="line">                          <span class="comment"># properties=pika.BasicProperties(delivery_mode=2),</span></span><br><span class="line">                          body=msg)</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line">connection.close()</span><br><span class="line">==========================================================================================</span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">from</span> pika.adapters.blocking_connection <span class="keyword">import</span> BlockingChannel</span><br><span class="line"></span><br><span class="line">param = pika.URLParameters(<span class="string">&#x27;amqp://cloud:cloud@192.168.24.157:5672/test&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(param)  <span class="comment"># 使用此参数去连接</span></span><br><span class="line">channel: BlockingChannel = connection.channel()</span><br><span class="line">ex_name = <span class="string">&#x27;products&#x27;</span>  <span class="comment"># 绑定</span></span><br><span class="line">ex_type = <span class="string">&#x27;topic&#x27;</span></span><br><span class="line">q_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">products = (<span class="string">&#x27;pc&#x27;</span>, <span class="string">&#x27;phone&#x27;</span>, <span class="string">&#x27;tv&#x27;</span>)</span><br><span class="line">colors = (<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">topics = (<span class="string">&#x27;phone.*&#x27;</span>, <span class="string">&#x27;*.red&#x27;</span>)</span><br><span class="line">channel.exchange_declare(exchange=ex_name, exchange_type=ex_type)</span><br><span class="line">channel.exchange_declare(exchange=ex_name, exchange_type=ex_type)</span><br><span class="line">result1 = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)  <span class="comment"># queue连接断开就消亡</span></span><br><span class="line">q_name1 = result1.method.queue</span><br><span class="line">channel.queue_bind(q_name1, ex_name, topics[<span class="number">0</span>])</span><br><span class="line">result2 = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)  <span class="comment"># queue连接断开就消亡</span></span><br><span class="line">q_name2 = result2.method.queue</span><br><span class="line"><span class="comment"># channel.queue_bind(exchange=ex_name, queue=q_name2)</span></span><br><span class="line">channel.queue_bind(q_name2, ex_name, topics[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费端直接去queue里拿</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    ctag = method.consumer_tag</span><br><span class="line">    dtag = method.delivery_tag</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;|&#123;&#125; ** &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ctag, dtag, body))</span><br><span class="line">    <span class="comment"># channel.basic_ack(dtag)  # 手动应答</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = channel.basic_consume(queue=q_name1,</span><br><span class="line">                           auto_ack=<span class="literal">True</span>,  <span class="comment"># 取消自动应答</span></span><br><span class="line">                           on_message_callback=callback)</span><br><span class="line">c2 = channel.basic_consume(queue=q_name2,</span><br><span class="line">                           auto_ack=<span class="literal">False</span>,  <span class="comment"># 取消自动应答</span></span><br><span class="line">                           on_message_callback=callback)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()  <span class="comment"># 产生阻塞 有就去消费</span></span><br><span class="line">connection.close()</span><br><span class="line"></span><br><span class="line">==========================================================================================</span><br><span class="line">ctag1<span class="number">.6</span>fc9de865eff46c1878f65ce2a5c8fe4|<span class="number">21</span> ** <span class="string">b&#x27;phone.red-data-  1&#x27;</span></span><br><span class="line">ctag1<span class="number">.2</span>e9e383b51894161bafa4071435eaa21|<span class="number">22</span> ** <span class="string">b&#x27;phone.red-data-  1&#x27;</span></span><br><span class="line">ctag1<span class="number">.2</span>e9e383b51894161bafa4071435eaa21|<span class="number">23</span> ** <span class="string">b&#x27;phone.black-data-  2&#x27;</span></span><br><span class="line">ctag1<span class="number">.6</span>fc9de865eff46c1878f65ce2a5c8fe4|<span class="number">24</span> ** <span class="string">b&#x27;tv.red-data-  3&#x27;</span></span><br><span class="line"></span><br><span class="line">观察消费者拿到的数据，注意观察phone.red的数据出现的次数。</span><br><span class="line">由此，可以知道交换机在路由消息的时候，只要和queue的routing key匹配，就把消息发给该queue。</span><br></pre></td></tr></table></figure>



<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><blockquote>
<p>RabbitMQ的RPC的应用场景较少，因为有更好的RPC通信框架。</p>
</blockquote>
<h1 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h1><ul>
<li>系统间解耦</li>
<li>解决生产者、消费者速度匹配</li>
<li>高峰时缓冲 低谷有事可做（拦河大坝）</li>
</ul>
<blockquote>
<p>由于稍微上规模的项目都会分层、分模块开发,模块间或系统间尽量不要直接耦合,需要开放公共接口<br>提供给别的模块或系统调用，而调用可能触发并发问题，为了缓冲和解耦,往往采用中间件技术。</p>
<p>RabbitMQ只是消息中间件中的一种应用程序，也是较常用的消息中间件服务。</p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH原理与实践</title>
    <url>/2023/10/18/SSH%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>介绍：SH（Secure Shell，安全外壳）是一种网络安全协议，通过加密和认证机制实现安全的访问和文件传输等业务。传统远程登录或文件传输方式，例如Telnet、FTP，使用明文传输数据，存在很多的安全隐患。随着人们对网络安全的重视，这些方式已经慢慢不被接受。SSH协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的登录和其他安全网络服务。作为Telnet和其他不安全远程shell协议的安全替代方案，目前SSH协议已经被全世界广泛使用，大多数设备都支持SSH功能。</p>
<span id="more"></span>

<h1 id="SSH原理与实践"><a href="#SSH原理与实践" class="headerlink" title="SSH原理与实践"></a>SSH原理与实践</h1><h2 id="SSH简介"><a href="#SSH简介" class="headerlink" title="SSH简介"></a>SSH简介</h2><ul>
<li>SSH（Secure Shell，安全外壳协议）是一种用于在不安全网络上进行安全远程登录和实现其他安全网络服务的协议。</li>
<li>SSH协议由三个组件构成：SSH传输层协议，SSH用户认证协议，SSH连接协议。<ul>
<li>SSH传输层协议：版本协商、算法协商、密钥交换</li>
<li>SSH用户认证协议：用户认证（口令、密钥）</li>
<li>SSH连接协议：建立会话连接</li>
</ul>
</li>
</ul>
<h1 id="密码学补充"><a href="#密码学补充" class="headerlink" title="密码学补充"></a>密码学补充</h1><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><ul>
<li>对称加密 ：加密和解密使用的是同一把密钥<ul>
<li>优点：加密速度快</li>
<li>缺点：不安全，密钥在传输过程当中存在安全风险</li>
</ul>
</li>
</ul>
<p><img src="image-20220617145822207.png" alt="image-20220617145822207"></p>
<ul>
<li><p>非对称加密：每一方拥有两把钥匙，一把叫做公钥，一把叫私钥：公钥加密，私钥解密；私钥加密，公钥解密</p>
<ul>
<li><p>优点：安全，私钥是保存在本地的，也就意味着，即便密文被获取到，也无法进行解密</p>
</li>
<li><p>缺点：加密速度慢。虽然攻击者无法通过密文得到明文信息，但是可以篡改信息</p>
</li>
</ul>
</li>
</ul>
<p><img src="image-20220617145855011.png" alt="image-20220617145855011"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如何获取对方的公钥：</span><br><span class="line"><span class="number">1.</span>发起请求来获取</span><br><span class="line"><span class="number">2.</span>可以将自己的公钥放在一台公共的服务器上</span><br></pre></td></tr></table></figure>



<h2 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h2><ul>
<li>核心概念：对于明文还是采用对称加密的方式，而对于对称加密的密钥，采用非对称加密的方式</li>
<li>优点：在保证安全性的前提下，又提升了加密的速度</li>
<li>缺点：虽然攻击者无法通过密文得到明文信息，但是可以篡改信息</li>
</ul>
<p><img src="image-20220617145937979.png" alt="image-20220617145937979"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">此时假设甲向乙发送信息：</span><br><span class="line"><span class="number">1.</span>甲采用对称密钥对明文信息进行加密</span><br><span class="line"><span class="number">2.</span>甲使用乙的公钥对对称密钥进行加密，得到就是数字信封</span><br><span class="line"><span class="number">3.</span>甲将密文以及数字信封发送给乙</span><br><span class="line"><span class="number">4.</span>乙收到密文以及数字信封之后，先用自己的私钥对数字信封进行解密，得到对称密钥</span><br><span class="line"><span class="number">5.</span>乙使用解密得到的对称密钥再对密文信息进行解密，得到最原始的明文信息</span><br></pre></td></tr></table></figure>





<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p><img src="image-20220617150000236.png" alt="image-20220617150000236"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">假设甲要向乙发送信息</span><br><span class="line"><span class="number">1.</span>甲采用对称密钥对明文信息进行加密</span><br><span class="line"><span class="number">2.</span>甲使用乙的公钥对对称密钥进行加密，得到就是数字信封</span><br><span class="line"><span class="number">3.</span>甲将最原始的明文信息通过<span class="built_in">hash</span>计算得到一段<span class="built_in">hash</span>-<span class="number">1</span>值，并将该<span class="built_in">hash</span>值使用甲的私钥进行加密，得到一个数字签名</span><br><span class="line"><span class="number">4.</span>甲将密文、数字信封以及数字签名发送给乙</span><br><span class="line"><span class="number">5.</span>乙通过自己的私钥对数字信封进行解密，得到对称密钥</span><br><span class="line"><span class="number">6.</span>乙使用对称密钥对密文信息进行解密，得到明文信息</span><br><span class="line"><span class="number">7.</span>乙使用该明文信息通过<span class="built_in">hash</span>计算得到一段<span class="built_in">hash</span>-<span class="number">2</span>值</span><br><span class="line"><span class="number">8.</span>乙使用甲的公钥对数字签名进行解密，得到<span class="built_in">hash</span>-<span class="number">1</span>值</span><br><span class="line"><span class="number">9.</span>乙将<span class="built_in">hash</span>-<span class="number">1</span> 和<span class="built_in">hash</span>-<span class="number">2</span>进行比对，如果相同，则可以判定信息没有被篡改，或者说一定是甲发送的信息</span><br></pre></td></tr></table></figure>



<h1 id="SSH传输层协议"><a href="#SSH传输层协议" class="headerlink" title="SSH传输层协议"></a>SSH传输层协议</h1><p><img src="image-20220617152725857.png" alt="image-20220617152725857"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">密钥交换算法：双方根据该算法生成一个对称加密的密钥，用于后续报文的加密</span><br><span class="line">公钥算法：用于用户认证时选择哪种算法进行非对称加密</span><br><span class="line">对称加密算法：用于报文在进行对称加密时采用哪种对称加密的算法</span><br><span class="line">消息认证算法：用于数据完整性的认证</span><br></pre></td></tr></table></figure>



<h1 id="用户认证原理"><a href="#用户认证原理" class="headerlink" title="用户认证原理"></a>用户认证原理</h1><ul>
<li>口令认证（账号密码认证）</li>
</ul>
<p><img src="image-20220617151729483.png" alt="image-20220617151729483"></p>
<ul>
<li>公钥认证（免密登录）</li>
</ul>
<p><img src="image-20220617151805850.png" alt="image-20220617151805850"></p>
<ul>
<li>免密登录虽然不用输入账号密码，但是需要事先将客户端的公钥保存在服务器中</li>
</ul>
<h1 id="SSH连接协议"><a href="#SSH连接协议" class="headerlink" title="SSH连接协议"></a>SSH连接协议</h1><p><img src="image-20220617152621092.png" alt="image-20220617152621092"></p>
]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP基础</title>
    <url>/2023/10/15/TCP-IP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>摘要：TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p>
<span id="more"></span>

<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h3 id="1-1对比"><a href="#1-1对比" class="headerlink" title="1.1对比"></a>1.1对比</h3><table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接类型</td>
<td>面向连接</td>
<td>面向无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>有序</td>
<td>数据包有序号</td>
<td>没有序号</td>
</tr>
<tr>
<td>使用场景</td>
<td>数据不能出任何问题</td>
<td>视频 音频</td>
</tr>
</tbody></table>
<ul>
<li><p>连接</p>
<ul>
<li>TCP需要通讯双方预先建立连接 三次握手 四次挥手</li>
<li>UDP不需要预先建立连接</li>
</ul>
</li>
<li><p>可靠性</p>
<ul>
<li>TCP需要确定每一个包的接收 丢包重发 效率低</li>
<li>UDP尽力交付数据 不需要确认数据包 丢包无法知道 也不重复 效率高</li>
</ul>
</li>
<li><p>有序</p>
<ul>
<li>TCP包有序号 可进行顺序控制 第一个包序号随机生成 之后的序号都和它有关</li>
<li>UDP包无序 无法纠正 只能在应用层进行验证</li>
</ul>
</li>
</ul>
<h2 id="二、三次握手"><a href="#二、三次握手" class="headerlink" title="二、三次握手"></a>二、三次握手</h2><h3 id="2-1图解"><a href="#2-1图解" class="headerlink" title="2.1图解"></a>2.1图解</h3><p><img src="image-20230729113206627.png" alt="image-20230729113206627"></p>
<h3 id="2-2说明"><a href="#2-2说明" class="headerlink" title="2.2说明"></a>2.2说明</h3><p><img src="image-20230729135210005.png" alt="image-20230729135210005"></p>
<h2 id="三、四次断开"><a href="#三、四次断开" class="headerlink" title="三、四次断开"></a>三、四次断开</h2><h3 id="3-1图解"><a href="#3-1图解" class="headerlink" title="3.1图解"></a>3.1图解</h3><p><img src="image-20230729135651868.png" alt="image-20230729135651868"></p>
<h3 id="3-2说明"><a href="#3-2说明" class="headerlink" title="3.2说明"></a>3.2说明</h3><p><strong><img src="image-20230729140242969.png" alt="image-20230729140242969"></strong></p>
]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>python 基础语法</title>
    <url>/2023/10/15/python-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>摘要:    description: 介绍了python基础语法</p>
<span id="more"></span>


<h1 id="02-基础语法"><a href="#02-基础语法" class="headerlink" title="02. 基础语法"></a>02. 基础语法</h1><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>由于计算机只能够识别1跟0两种信号，那么就需要我们将信息转换成计算机所能够理解的信号，</p>
<p>因此编码的本质就是人所能够理解的字符与计算机所能够理解的二进制之间的对应关系，也就是类似于密码本一样的东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">马   0000 0001</span><br><span class="line">琨   0000 0010</span><br><span class="line">琪   0000 0011</span><br></pre></td></tr></table></figure>

<p>不同的编码模式对于同一个字符可能会存在不同的对应关系</p>
<h3 id="1-2-ASCII编码"><a href="#1-2-ASCII编码" class="headerlink" title="1.2 ASCII编码"></a>1.2 ASCII编码</h3><blockquote>
<p><a href="http://www.lookuptables.com/">www.lookuptables.com</a></p>
</blockquote>
<p>最早期一种编码模式，采用一个字节来表示对应关系，由于一个字节等于8个bit的长度，共有256种对应方式</p>
<p>因此只能够对一些指令，常见的符号，以及数字和英文字符提供码位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A--65--01000001</span><br></pre></td></tr></table></figure>

<h3 id="1-3-GBK编码"><a href="#1-3-GBK编码" class="headerlink" title="1.3 GBK编码"></a>1.3 GBK编码</h3><p>GB2312，中国指定的编码标准，为中国的汉字提供了二进制的码位。</p>
<p>GBK编码就是在GB2312的基础上发展起来的，也为日韩相关的文字提供了二进制的码位</p>
<ul>
<li><p>使用一个字节来表示对应关系</p>
</li>
<li><p>使用两个字节来表示对应关系（16bit 65536）</p>
</li>
</ul>
<h3 id="1-4-UNICODE编码"><a href="#1-4-UNICODE编码" class="headerlink" title="1.4 UNICODE编码"></a>1.4 UNICODE编码</h3><p>万国码，为全球的每一个文字都提供了一个二进制的码位</p>
<ul>
<li><p>USC2，使用两个字节来表示对应关系</p>
</li>
<li><p>USC4，使用四个字节来表示对应关系（32bit 42.9亿）</p>
</li>
</ul>
<p>在进行存储和数据传输时，会浪费大量的空间</p>
<p>假设我们举一个非常极端的例子，假设使用ASCII编码存储一个G的A，此时对应的使用unicode编码要占用4个G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A--65--01000001  ASCII</span><br><span class="line">A--01000001 01000001 01000001 01000001 unicode</span><br></pre></td></tr></table></figure>

<p>在内存中处理数据时，一般都会采用unicode编码</p>
<h3 id="1-5-UTF-8编码"><a href="#1-5-UTF-8编码" class="headerlink" title="1.5 UTF-8编码"></a>1.5 UTF-8编码</h3><p>utf-8编码也可以为全球的每一个文字都提供了一个二进制的码位，但在unicode的基础上进行了压缩</p>
<p>使用一个字节来表示对应关系</p>
<p>使用两个字节来表示对应关系</p>
<p>使用三个字节来表示对应关系</p>
<p>使用四个字节来表示对应关系</p>
<p>因此UTF-8的编码适合进行数据的存储以及数据的传输</p>
<h3 id="1-6-乱码"><a href="#1-6-乱码" class="headerlink" title="1.6 乱码"></a>1.6 乱码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">马--<span class="number">65</span>--<span class="number">0</span>1000001  <span class="number">0</span>1000001 GBK</span><br><span class="line">       <span class="number">0</span>1000001  <span class="number">0</span>1000001 UTF-<span class="number">8</span>  </span><br><span class="line">       找不到就会出现乱码</span><br><span class="line">目前的文件默认采用的都是utf-<span class="number">8</span>的编码，如果想要改变默认的编码模式，可以在python文件的头部加上一段代码</span><br><span class="line"><span class="comment"># 默认的编码模式改为GBK</span></span><br><span class="line"><span class="comment"># -*- coding:GBK -*-  </span></span><br><span class="line">即便能够这样改变编码模式，但是建议还是采用UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>



<h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><h3 id="2-1-进制在python中的表示"><a href="#2-1-进制在python中的表示" class="headerlink" title="2.1 进制在python中的表示"></a>2.1 进制在python中的表示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制       int</span><br><span class="line">二进制       bin</span><br><span class="line">八进制       oct</span><br><span class="line">十六进制     hex</span><br></pre></td></tr></table></figure>



<h3 id="2-2-进制转换方法"><a href="#2-2-进制转换方法" class="headerlink" title="2.2 进制转换方法"></a>2.2 进制转换方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>将十进制转成二进制</span><br><span class="line">v1 = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(v1))</span><br><span class="line"><span class="number">0b1010</span></span><br><span class="line"><span class="number">2.</span>将十进制转成八进制</span><br><span class="line">v1 = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(v1))</span><br><span class="line"><span class="number">0o12</span></span><br><span class="line"><span class="number">3.</span>将十进制转成十六进制</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(v1))</span><br><span class="line"><span class="number">0xa</span></span><br><span class="line"><span class="number">4.</span>将<span class="number">2</span>进制转成十进制</span><br><span class="line">v1 = <span class="string">&#x27;0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(v1,base=<span class="number">2</span>))</span><br><span class="line"><span class="number">5.</span>将<span class="number">8</span>进制转成十进制</span><br><span class="line">v1 = <span class="string">&#x27;0o12&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(v1,base=<span class="number">8</span>))</span><br><span class="line"><span class="number">6.</span>将十六进制转成十进制</span><br><span class="line">v1 = <span class="string">&#x27;0xa&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(v1,base=<span class="number">16</span>))</span><br><span class="line"><span class="number">7.</span>将二进制转成十六进制</span><br><span class="line">v1 = <span class="string">&#x27;0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>(v1,base=<span class="number">2</span>)))</span><br><span class="line"><span class="number">0xa</span></span><br><span class="line">v1 = <span class="number">0b1010</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(v1))</span><br></pre></td></tr></table></figure>



<h2 id="3-基本常用函数"><a href="#3-基本常用函数" class="headerlink" title="3. 基本常用函数"></a>3. 基本常用函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数就是一个功能的集合</span><br></pre></td></tr></table></figure>

<h3 id="3-1-print"><a href="#3-1-print" class="headerlink" title="3.1 print"></a>3.1 print</h3><h4 id="3-1-1-print函数的功能"><a href="#3-1-1-print函数的功能" class="headerlink" title="3.1.1 print函数的功能"></a>3.1.1 print函数的功能</h4><p>输出一段内容，显示给用户</p>
<h4 id="3-1-2-常用参数"><a href="#3-1-2-常用参数" class="headerlink" title="3.1.2 常用参数"></a>3.1.2 常用参数</h4><ul>
<li>end：输出内容之后默认采用的符号，默认是换行符\n</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;123&quot;,end=&quot;,&quot;)</span><br><span class="line">print(&quot;456&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>sep：输出多段内容之间连接的符号，默认是空格</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;123&quot;, &quot;456&quot;,sep=&quot;,&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-input"><a href="#3-2-input" class="headerlink" title="3.2 input"></a>3.2 input</h3><ul>
<li>作用：跟用户做一个交互，接收用户输入的一段内容，注意：通过input方法接收到的值是字符串类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(name)+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><h3 id="4-1-变量的本质"><a href="#4-1-变量的本质" class="headerlink" title="4.1 变量的本质"></a>4.1 变量的本质</h3><p>变量就是一种容器，指向某一块内存地址</p>
<p>假设现在我们将整个内存当成一个非常大的仓库，取件码 货物 货物实际存放的位置</p>
<p>完整的变量：变量名，变量值，内存地址</p>
<h5 id="4-2-变量定义-调用"><a href="#4-2-变量定义-调用" class="headerlink" title="4.2 变量定义&amp;调用"></a>4.2 变量定义&amp;调用</h5><p>变量必须先定义，再调用</p>
<p>定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">gender = <span class="string">&quot;male&quot;</span></span><br><span class="line">a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line">info = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name:&#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(name)</span><br><span class="line"><span class="built_in">print</span>(info)</span><br></pre></td></tr></table></figure>



<h5 id="4-3-变量定义规则"><a href="#4-3-变量定义规则" class="headerlink" title="4.3 变量定义规则"></a>4.3 变量定义规则</h5><ul>
<li>变量名只能由字母、数字、下划线来组成</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ = <span class="number">123</span> <span class="comment">#错误的变量名</span></span><br><span class="line">name_1 = <span class="number">123</span> <span class="comment">#正确的变量名</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能以数字开头</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">1name = <span class="number">123</span> <span class="comment">#错误的变量名</span></span><br><span class="line">name1 = <span class="number">123</span> <span class="comment">#正确的变量名</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能用python中的关键字来作为变量名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> = <span class="number">123</span> <span class="comment">#错误的示范，语法上不会出错，但是会影响原有关键字的功能</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">print</span></span><br><span class="line"><span class="keyword">break</span> <span class="keyword">continue</span> <span class="keyword">pass</span>... //不要用</span><br></pre></td></tr></table></figure>

<h5 id="4-4-变量命名规范"><a href="#4-4-变量命名规范" class="headerlink" title="4.4 变量命名规范"></a>4.4 变量命名规范</h5><p>PEP8规范：业界定义的一种规范，理论上来讲不需要强制遵守，但是建议采用这种格式</p>
<p>在pycharm当中可以自动的检查代码是否符合PEP8的规范，使用快捷键Ctrl+Alt+L来进行调整</p>
<ul>
<li>在定义变量时，尽量使用英文，不要使用拼音的缩写</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xuehao = <span class="string">&quot;123456&quot;</span> <span class="comment">#错误的命名规范</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下划线连接：一般来说，定义变量，函数时采用下划线连接</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student_id = <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>驼峰体：定义类的时候采用驼峰体</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">StudentId = <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="4-5-变量的修改与删除"><a href="#4-5-变量的修改与删除" class="headerlink" title="4.5 变量的修改与删除"></a>4.5 变量的修改与删除</h5><ul>
<li>场景1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>场景2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">name = <span class="string">&quot;李四&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>场景3</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">new_name = name</span><br></pre></td></tr></table></figure>

<ul>
<li>场景4</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">new_name = name</span><br><span class="line">name = <span class="string">&quot;李四&quot;</span></span><br><span class="line">new_name = name</span><br></pre></td></tr></table></figure>

<ul>
<li>场景5</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">18</span></span><br><span class="line">age = <span class="built_in">str</span>(num)</span><br></pre></td></tr></table></figure>

<ul>
<li>场景6</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="keyword">del</span> name</span><br></pre></td></tr></table></figure>



<h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h3><p>在编写代码的时候，我们需要对某些内容进行注释，解释器会忽略注释后的代码，不会执行</p>
<ul>
<li><p>注释代码，程序运行时，不会执行已经被注释掉的代码</p>
<ul>
<li>单行注释</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(123)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多行注释</li>
</ul>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name = &quot;张三&quot;</span></span><br><span class="line"><span class="comment"># new_name = name</span></span><br><span class="line"><span class="comment"># name = &quot;李四&quot;</span></span><br><span class="line"><span class="comment"># new_name = name</span></span><br><span class="line"><span class="comment"># print(new_name,name)</span></span><br><span class="line"></span><br><span class="line">全部选中 Ctrl+/</span><br></pre></td></tr></table></figure>
</li>
<li><p>对一些变量或者方法做解释说明</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span>  <span class="comment"># 定义一个名为张三的姓名</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>hello hexo -_-</title>
    <url>/2023/10/15/hello-hexo/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容1</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容2</p>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p>YzzCloud</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图片显示测试</title>
    <url>/2023/10/15/testimg/</url>
    <content><![CDATA[<p>description: -_-</p>
<p><img src="image-20231015214211675.png" alt="image-20231015214211675"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo-Next</tag>
      </tags>
  </entry>
  <entry>
    <title>vxlan基础介绍</title>
    <url>/2023/10/17/vxlan%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>description：</p>
<blockquote>
<p>VXLAN是一种网络虚拟化技术，可以改进大型云计算在部署时的扩展问题，是对VLAN的一种扩展。VXLAN是一种功能强大的工具，可以穿透三层网络对二层进行扩展。它可通过封装流量并将其扩展到第三层网关，以此来解决VMS（虚拟内存系统）的可移植性限制，使其可以访问在外部IP子网上的服务器。</p>
</blockquote>
<span id="more"></span>

<h1 id="vxlan初试"><a href="#vxlan初试" class="headerlink" title="vxlan初试"></a>vxlan初试</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="def"><a href="#def" class="headerlink" title="def"></a>def</h3><p>&#x3D;&#x3D;大二层&#x3D;&#x3D;</p>
<ul>
<li>虚拟机摆脱地理位置的限制自由迁移，构建跨地理区域的大二层网络。</li>
<li>要求网络横向流量提供无阻塞的能力</li>
<li>构建跨地理区域的服务器集群，提高系统容灾能力</li>
</ul>
<ol>
<li>一种点到点的隧道技术，隧道本质是对报文的重新封装，利用封装后的信息进行报文的转发。</li>
<li>vxlan是无控制平面的隧道技术。【有控制那个面的隧道技术：LSP（LDP&#x2F;BGP)，IPsec VPN(IKEv1,IKEv2), L2TP, SSL VPN ,VPLS】</li>
<li>实际上vxlan可以利用evn，evpn协议，sdn控制器来充当它的控制平面。</li>
<li>vxlan能实现2层互访（同子网互访），3层互访，也可以和传统vlan网络结合组网部署。</li>
<li>基于IP的封装，封装的对象始终是数据帧。</li>
</ol>
<h3 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h3><ul>
<li>Point of Delivery </li>
<li>既可以是物理的，也可以说逻辑的数据中心功能模块，一个POD，可以包含机柜、服务器及网络设备、以及相应的基础设施。</li>
</ul>
<p>&#x3D;&#x3D;传统数据中心架构网络&#x3D;&#x3D;</p>
<p><img src="image-20230720195825429.png" alt="image-20230720195825429"></p>
<p>传统网络大不起来？</p>
<ol>
<li>STP阻塞链路，浪费带宽</li>
<li>用CSS，M-LAG，纯二层网络广播泛洪范围太长，所有设备都要维护MAC地址表，表项容量存在DC扩容的瓶颈。</li>
</ol>
<p>云计算时代网络设计？（胖数据网 | Spnie+leaf组网）</p>
<ol>
<li>纯IP网络</li>
<li>扁平化</li>
<li>无阻赛链路</li>
<li>可靠，可扩展</li>
<li>大二层</li>
<li>报文转发不超过三台设备</li>
</ol>
<p><img src="image-20230720202038590.png" alt="image-20230720202038590"></p>
<p><img src="image-20230720202618943.png" alt="image-20230720202618943"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="NVE"><a href="#NVE" class="headerlink" title="NVE"></a>NVE</h3><ul>
<li><p>networkl virtualization edge：</p>
</li>
<li><p>网络虚拟化边缘设备，进行vxlan封装和解封装的设备。</p>
</li>
<li><p>位于overlay网络的边界，实现二、三层的虚拟化功能。</p>
</li>
</ul>
<h3 id="vxlan"><a href="#vxlan" class="headerlink" title="vxlan"></a>vxlan</h3><p>virtual extensible lan</p>
<ul>
<li>虚拟可扩展局域网</li>
<li>通过LMAC in udp 的报文封装方式，实现基于IP overlay的虚拟局域网</li>
<li>vxlan网络中的NVE以VTEP进行标识</li>
</ul>
<h3 id="VTEP"><a href="#VTEP" class="headerlink" title="VTEP"></a>VTEP</h3><ul>
<li>vxlan tunnel endpoint </li>
<li>vxlan隧道端点</li>
<li>每一个NVE至少有一个VTEP，VTEP使用NVE的IP地址表示</li>
<li>两个VTEP可以确定一条vxlan隧道</li>
</ul>
<p><img src="image-20230720205538515.png" alt="image-20230720205538515"></p>
<h3 id="逻辑抽象"><a href="#逻辑抽象" class="headerlink" title="逻辑抽象"></a>逻辑抽象</h3><p><img src="image-20230720205715739.png" alt="image-20230720205715739"></p>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p><img src="image-20230720210338414.png" alt="image-20230720210338414"></p>
<h3 id="vni"><a href="#vni" class="headerlink" title="vni"></a>vni</h3><ul>
<li>表示不同的广播域</li>
</ul>
<h3 id="udp-port"><a href="#udp-port" class="headerlink" title="udp port"></a>udp port</h3><ul>
<li>通过原始帧的SMAC+DMAC hash 后的值。</li>
<li>Dport 4789 代表vxlan</li>
<li>目前ensp 的sport 和dport 都是4789</li>
</ul>
<p>添加udp封装的原因？</p>
<p>- </p>
<p><img src="image-20230720210745483.png" alt="image-20230720210745483"></p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>vxlan？什么样的流量需要vxlan需要封装</p>
]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>vxlan</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程基础</title>
    <url>/2023/10/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>摘要:   程序如何提升速度？</p>
<p>① 单线程串行：由CPU 和 IO 轮流执行；② 多线程并发（threading）③ 多CPU 并行（multiprocessing）④ 多机器并行；</p>
<span id="more"></span>

<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="操作系统发展史"><a href="#操作系统发展史" class="headerlink" title="操作系统发展史"></a>操作系统发展史</h3><p>操作系统的发展史，本质上就是不断地提高CPU利用率的过程</p>
<h2 id="多道技术"><a href="#多道技术" class="headerlink" title="多道技术"></a>多道技术</h2><p>单核实现并发的效果</p>
<p>1.I&#x2F;O的操作（输入，输出，网络传输）</p>
<p>2.计算数据</p>
<h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><p>根据顺序，依次执行，CPU的利用率非常低</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li>并发</li>
</ul>
<p>看起来像是在同时执行，就叫做并发</p>
<ul>
<li>并行</li>
</ul>
<p>实际上的确在同时执行，就叫做并行</p>
<p>所以，并行一定可以叫做并发，但是并发不一定叫做并行</p>
<ul>
<li>串行和并行</li>
</ul>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><ul>
<li>空间上的复用</li>
</ul>
<p>​	多个应用程序共用一套硬件</p>
<ul>
<li>时间上的复用</li>
</ul>
<p>​	在同一时间，同时做着很多事情：点外卖，洗衣服，学习</p>
<h3 id="cpu是如何切换的"><a href="#cpu是如何切换的" class="headerlink" title="cpu是如何切换的"></a>cpu是如何切换的</h3><p>1.I&#x2F;O操作的时候，主动释放CPU的使用权限</p>
<p>2.长时间占用，剥夺CPU的使用权限</p>
<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>程序是死的，进程是活的</p>
<ul>
<li>程序</li>
</ul>
<p>程序实际就相当于一大段功能代码的集合</p>
<ul>
<li>进程</li>
</ul>
<p>进程指的就是程序实际执行的过程</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>当多个进程同时执行时，需要分配CPU的资源，而这个分配过程不是随机的，而是遵循一定的规则，那这个规则就需要进程的调度算法</p>
<ul>
<li>先来先服务调度算法：对长作业有利</li>
<li>短作业优先调度算法：对短作业有利</li>
<li>时间片轮转法+多级反馈队列</li>
</ul>
<h2 id="进程与线程概述"><a href="#进程与线程概述" class="headerlink" title="进程与线程概述"></a>进程与线程概述</h2><h3 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h3><ul>
<li>进程指的就是程序执行的过程，线程是进程工作的最小单位</li>
</ul>
<p>假设应用程序相当于是一个工厂（生产东西-数据的），此时进程就相当于是工厂的车间，而线程就相当于是车间的工人，因此每个进程最少要存在一个线程</p>
<p>此时如果我们想要提高生产效率：1.扩车间 2.每个车间增加工人</p>
<p>进程和线程分别是在什么的基础上创建出来的？</p>
<p>进程是在程序的基础上申请额外的内存空间</p>
<p>线程是在进程的基础上增加线程</p>
<p>因此进程是比线程消耗资源更多的方式</p>
<h3 id="初识多进程、多线程"><a href="#初识多进程、多线程" class="headerlink" title="初识多进程、多线程"></a>初识多进程、多线程</h3><ul>
<li>多线程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="comment"># 在这个示例中，并没有缩短执行时间</span></span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())  <span class="comment"># 1687596183.341898（引入线程）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    t = threading.Thread(target=func, args=(i, ))   <span class="comment"># 子线程</span></span><br><span class="line">    t.start()   <span class="comment"># 线程已经准备就绪，可以被调度</span></span><br><span class="line">    <span class="comment"># 1687596183.341898</span></span><br><span class="line">    <span class="comment"># 1687596215.4531312</span></span><br><span class="line">    <span class="comment"># 1687596215.513087</span></span><br></pre></td></tr></table></figure>



<ul>
<li>多进程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个示例中，并没有缩短执行时间</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    <span class="built_in">print</span>(time.time())  <span class="comment"># 1687595289.1904593（引入进程）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        t = multiprocessing.Process(target=func, args=(i,))  <span class="comment"># 进程</span></span><br><span class="line">        t.start()  <span class="comment"># 进程已经准备就绪，可以被调度</span></span><br><span class="line"><span class="comment"># 1687596004.0196815</span></span><br><span class="line"><span class="comment"># 1687596022.0709853</span></span><br><span class="line"><span class="comment"># 1687596022.2699168        </span></span><br></pre></td></tr></table></figure>



<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process 是内置模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 24s---&gt;12s</span></span><br><span class="line"><span class="comment"># 在windows系统下，创建进程必须在if __name__ == &#x27;__main__&#x27;:下</span></span><br><span class="line"><span class="comment"># 这是因为在windows系统下，创建进程是以模块导入的形式进行创建</span></span><br><span class="line"><span class="comment"># 如果不在if __name__ == &#x27;__main__&#x27;:创建，每次导入都会重新创建一个进程，不断循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        p = Process(target=func, args=(i,))  <span class="comment"># 创建进程，注意target接的参数不要带括号，同时args跟的参数要加逗号（元组）</span></span><br><span class="line">        p.start() <span class="comment"># 启动进程</span></span><br><span class="line">    <span class="comment"># 在子进程执行的过程当中，主进程不会等到子进程执行完毕</span></span><br><span class="line">    <span class="comment"># print(time.time())</span></span><br></pre></td></tr></table></figure>

<ul>
<li>join方法</li>
</ul>
<p>通过该方法，可以让主进程等待子进程结束之后再执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process 是内置模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 24s---&gt;12s</span></span><br><span class="line"><span class="comment"># 在windows系统下，创建进程必须在if __name__ == &#x27;__main__&#x27;:下</span></span><br><span class="line"><span class="comment"># 这是因为在windows系统下，创建进程是以模块导入的形式进行创建</span></span><br><span class="line"><span class="comment"># 如果不在if __name__ == &#x27;__main__&#x27;:创建，每次导入都会重新创建一个进程，不断循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        p = Process(target=func, args=(i,))  <span class="comment"># 创建进程，注意target接的参数不要带括号，同时args跟的参数要加逗号（元组）</span></span><br><span class="line">        p.start() <span class="comment"># 启动进程</span></span><br><span class="line">        p.join()  <span class="comment"># 使用了join方法之后，代表主进程必须等待该进程结束之后才能执行</span></span><br><span class="line">    <span class="comment"># 在子进程执行的过程当中，主进程不会等到子进程执行完毕</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br></pre></td></tr></table></figure>

<p>问题：在使用join方法时，如果让多个子进程同时执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process 是内置模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 24s---&gt;12s</span></span><br><span class="line"><span class="comment"># 在windows系统下，创建进程必须在if __name__ == &#x27;__main__&#x27;:下</span></span><br><span class="line"><span class="comment"># 这是因为在windows系统下，创建进程是以模块导入的形式进行创建</span></span><br><span class="line"><span class="comment"># 如果不在if __name__ == &#x27;__main__&#x27;:创建，每次导入都会重新创建一个进程，不断循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        p = Process(target=func, args=(i,))  <span class="comment"># 创建进程，注意target接的参数不要带括号，同时args跟的参数要加逗号（元组）</span></span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start() <span class="comment"># 启动进程  # 使用了join方法之后，代表主进程必须等待该进程结束之后才能执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> p_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用join方法时，如果让多个子进程同时执行</span></span><br></pre></td></tr></table></figure>

<h3 id="进程互斥锁"><a href="#进程互斥锁" class="headerlink" title="进程互斥锁"></a>进程互斥锁</h3><ul>
<li>当多个进程同时操作一份数据时，会出现数据错乱的情况</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;查看当前余票为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, dic.get(<span class="string">&quot;ticket_num&quot;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">name</span>):</span><br><span class="line">    search(name)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dic.get(<span class="string">&quot;ticket_num&quot;</span>) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票成功！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">        dic[<span class="string">&quot;ticket_num&quot;</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(dic,f)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票失败！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        p = Process(target=buy,args=(i,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>解决办法：添加互斥锁：就是将原有的并行变成串行，牺牲了执行效率，但是保护了数据安全</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;查看当前余票为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, dic.get(<span class="string">&quot;ticket_num&quot;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">name,mutex</span>):</span><br><span class="line">    search(name)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    mutex.acquire()  <span class="comment"># 抢锁</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dic.get(<span class="string">&quot;ticket_num&quot;</span>) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票成功！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">        dic[<span class="string">&quot;ticket_num&quot;</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(dic, f)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票失败！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">    mutex.release() <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mutex = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">        p = Process(target=buy, args=(i,mutex))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<h3 id="进程之间数据互相隔离"><a href="#进程之间数据互相隔离" class="headerlink" title="进程之间数据互相隔离"></a>进程之间数据互相隔离</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">666</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>



<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21s</span></span><br><span class="line"><span class="comment"># 23s</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        func(i)</span><br><span class="line">        t = Thread(target=func,args=(i,))</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br></pre></td></tr></table></figure>

<p>通过这个例子可以看到，通过多线程的方式没有办法提高程序的执行效率，没有缩短程序的执行时间，这是因为有GIL锁的存在</p>
<h3 id="GIL锁"><a href="#GIL锁" class="headerlink" title="GIL锁"></a>GIL锁</h3><ul>
<li>GIL锁其实是CPython当中设计的一个功能，它的目的就是让一个进程当中同一时间最多只有一个线程能被CPU调度</li>
<li>什么时候使用多进程，什么时候使用多线程？</li>
</ul>
<p>GIL锁让多线程丧失了多核优势，但是保证了数据安全</p>
<p>但并不是因为这样，多线程就没有了意义</p>
<p>&#x3D;&#x3D;I\O密集型：使用多线程，更多的文件存取，更多的网络传输&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;计算密集型：使用多进程，计算大量的数据&#x3D;&#x3D;</p>
<h3 id="同个进程的线程数据共享"><a href="#同个进程的线程数据共享" class="headerlink" title="同个进程的线程数据共享"></a>同个进程的线程数据共享</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">666</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=func)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抢GIL锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    n = num</span><br><span class="line">    num = n-<span class="number">1</span></span><br><span class="line"><span class="comment"># 释放GIL锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 开启了100个线程</span></span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br></pre></td></tr></table></figure>



<h3 id="线程互斥锁"><a href="#线程互斥锁" class="headerlink" title="线程互斥锁"></a>线程互斥锁</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抢GIL锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    n = num</span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># I/O操作</span></span><br><span class="line">    num = n-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 开启了100个线程</span></span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">mutex = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    n = num</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># I/O操作</span></span><br><span class="line">    num = n - <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">同时开启100个线程，此时每个线程要去抢夺两把锁，一把是GIL锁，一把是互斥锁</span></span><br><span class="line"><span class="string">此时线程遇到I/O操作会释放GIL锁，但是不会释放互斥锁</span></span><br><span class="line"><span class="string">必须等线程执行完毕才会释放互斥锁</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 开启了100个线程</span></span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<h3 id="并发的实现网络编程"><a href="#并发的实现网络编程" class="headerlink" title="并发的实现网络编程"></a>并发的实现网络编程</h3><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.__len__() == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">        obj = subprocess.Popen(args=cmd,</span><br><span class="line">                               shell=<span class="literal">True</span>,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE</span><br><span class="line">                               )</span><br><span class="line">        std_out = obj.stdout.read()</span><br><span class="line">        std_err = obj.stderr.read()</span><br><span class="line">        result = std_out + std_err</span><br><span class="line">        total_size = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(result))</span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(total_size)</span><br><span class="line">        conn.send(result)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">    t = Thread(target=func, args=(conn,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    total_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, client.recv(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> size &lt; total_size:</span><br><span class="line">        res += client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">        size += <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>





<h2 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h2><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><ul>
<li><p>start() </p>
<blockquote>
<p>线程准备就绪，等待CPU的调度（并不是说线程开始执行的意思，只是准备好了，具体什么时候执行，要看CPU具体的调度）</p>
</blockquote>
</li>
<li><p>join()</p>
</li>
</ul>
<blockquote>
<p>等待当前的线程执行完毕，再接着向下执行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个示例中，并没有缩短执行时间</span></span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">100000000</span>, <span class="number">100000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())  <span class="comment"># 1687596183.341898（引入线程）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    t = threading.Thread(target=func, args=(i,))  <span class="comment"># 子线程</span></span><br><span class="line">    t.start()  <span class="comment"># 线程已经准备就绪，可以被调度</span></span><br><span class="line">    t.join()    <span class="comment"># 当前线程等待结束之后，其余线程开始执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment"># 1687772202.2158334</span></span><br><span class="line"><span class="comment"># 123                   # 主线程没有等待子线程结束</span></span><br><span class="line"><span class="comment"># 1687772205.4652102</span></span><br><span class="line"><span class="comment"># 1687772205.4678156</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1687772266.6596544</span></span><br><span class="line"><span class="comment"># 1687772268.207551</span></span><br><span class="line"><span class="comment"># 1687772269.7452214</span></span><br><span class="line"><span class="comment"># 123                   # join之后</span></span><br></pre></td></tr></table></figure>



<ul>
<li>os.getpid()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, active_count, current_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line"><span class="built_in">print</span>(os.getpid())</span><br><span class="line">hello world <span class="number">5324</span></span><br><span class="line"><span class="number">5324</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>current_thread()	</p>
<blockquote>
<p>.name 获得当前性能名称</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># print(&quot;hello world&quot;, os.getpid())</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>, current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Thread(target=func)</span><br><span class="line">t1 = Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">t1.start()</span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(os.getpid())</span></span><br><span class="line"><span class="built_in">print</span>(current_thread().name)</span><br><span class="line">hello world Thread-<span class="number">1</span> (func)</span><br><span class="line">hello world Thread-<span class="number">2</span> (func)</span><br><span class="line">MainThread</span><br></pre></td></tr></table></figure>

<ul>
<li>active_count()	查出当前进程有多少个线程在执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># print(&quot;hello world&quot;, os.getpid())</span></span><br><span class="line">    <span class="comment"># print(&quot;hello world&quot;, current_thread().name)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=func)</span><br><span class="line">t2 = Thread(target=func)</span><br><span class="line">t1.start()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line"><span class="built_in">print</span>(active_count())</span><br><span class="line"><span class="comment"># t.join()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cloud&quot;</span>)</span><br><span class="line">hello world</span><br><span class="line">hello world2</span><br><span class="line"></span><br><span class="line">cloud</span><br></pre></td></tr></table></figure>



<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">100000000</span>, <span class="number">100000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    pool.submit(func, i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1687773791.3556776</span></span><br><span class="line"><span class="comment"># 1687773794.310415</span></span><br><span class="line"><span class="comment"># 1687773794.3211625</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===================================================================================</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">100000000</span>, <span class="number">100000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    pool.submit(func, i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1687773955.9518306</span></span><br><span class="line"><span class="comment"># 1687773957.6569276</span></span><br><span class="line"><span class="comment"># 1687773959.1737313</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="主线程等待子线程"><a href="#主线程等待子线程" class="headerlink" title="主线程等待子线程"></a>主线程等待子线程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;主线程执行代码&quot;</span>)</span><br><span class="line"><span class="comment"># 从threading 库导入Thread类</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">threadFunc</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子线程 开始&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程函数参数是：<span class="subst">&#123;arg1&#125;</span>, <span class="subst">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子线程 结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Thread类的实例对象，并且指定新线程的入口函数</span></span><br><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">&#x27;参数1&#x27;</span>, <span class="string">&#x27;参数2&#x27;</span>)</span><br><span class="line">                )	<span class="comment"># # 只是创建了一个Thread实例对象， 但这时，新的线程还没有创建。</span></span><br><span class="line"><span class="comment"># 执行start 方法，就会创建新线程</span></span><br><span class="line"><span class="comment"># 并且新线程会去执行入口函数里的代码</span></span><br><span class="line"><span class="comment"># 这时候 这个进程 就有两个线程了</span></span><br><span class="line">thread.start()		<span class="comment"># 新的线程才创建成功，并开始执行 入口函数threadFunc 里面的代码</span></span><br><span class="line"><span class="comment"># 主线程的代码执行，子线程对象的join方法</span></span><br><span class="line"><span class="comment"># 就会等待子线程结束，才继续执行下面的代码</span></span><br><span class="line">thread.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;主线程结束&quot;</span>)</span><br><span class="line"><span class="comment"># 主线程执行代码</span></span><br><span class="line"><span class="comment"># 子线程 开始</span></span><br><span class="line"><span class="comment"># 线程函数参数是：参数1, 参数2</span></span><br><span class="line"><span class="comment"># 主线程结束     # 主线程没有等待子线程运行结束：---解决措施，.join() 等待</span></span><br><span class="line"><span class="comment"># 子线程 结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程执行代码</span></span><br><span class="line"><span class="comment"># 子线程 开始</span></span><br><span class="line"><span class="comment"># 线程函数参数是：参数1, 参数2</span></span><br><span class="line"><span class="comment"># 子线程 结束    # 主线程等待子线程运行结束</span></span><br><span class="line"><span class="comment"># 主线程结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="共享数据的访问控制"><a href="#共享数据的访问控制" class="headerlink" title="共享数据的访问控制"></a>共享数据的访问控制</h3><ul>
<li>多线程没有加锁	<ul>
<li>结果不正常</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">&#x27;byhy&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">theadidx,amount</span>):</span><br><span class="line">    balance =  bank[<span class="string">&#x27;byhy&#x27;</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">&#x27;byhy&#x27;</span>]  = balance + amount</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程 <span class="subst">&#123;theadidx&#125;</span> 结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主线程结束&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">&quot;byhy&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">1</span></span><br></pre></td></tr></table></figure>



<ul>
<li>单线程运行<ul>
<li>结果无误</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">&#x27;byhy&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">theadidx,amount</span>):</span><br><span class="line">    balance =  bank[<span class="string">&#x27;byhy&#x27;</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">&#x27;byhy&#x27;</span>]  = balance + amount</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    deposit (idx,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">&quot;byhy&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>





<ul>
<li>多线程加锁<ul>
<li>结果正确运行</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">&#x27;byhy&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bankLock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">theadidx,amount</span>):</span><br><span class="line">    <span class="comment"># 操作共享数据前，申请获取锁</span></span><br><span class="line">    bankLock.acquire()</span><br><span class="line">    </span><br><span class="line">    balance =  bank[<span class="string">&#x27;byhy&#x27;</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">&#x27;byhy&#x27;</span>]  = balance + amount</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程 <span class="subst">&#123;theadidx&#125;</span> 结束&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 操作完共享数据后，申请释放锁</span></span><br><span class="line">    bankLock.release()</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主线程结束&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">&quot;byhy&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>Lock 对象的acquire方法 是申请锁。</p>
<p>每个线程在 操作共享数据对象之前，都应该 申请获取操作权，也就是 调用该 共享数据对象对应的锁对象的acquire方法。</p>
<p>如果线程A 执行如下代码，调用acquire方法的时候，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bankLock.acquire()</span><br></pre></td></tr></table></figure>

<p>别的线程B 已经申请到了这个锁， 并且还没有释放，那么 线程A的代码就在此处 等待 线程B 释放锁，不去执行后面的代码。</p>
<p>直到线程B 执行了锁的 release 方法释放了这个锁， 线程A 才可以获取这个锁，就可以执行下面的代码了。</p>
<p>如果这时线程B 又执行 这个锁的acquire方法， 就需要等待线程A 执行该锁对象的release方法释放锁， 否则也会等待，不去执行后面的代码。</p>
<p>多进程</p>
<p>Python 官方解释器 的每个线程要获得执行权限，必须获取一个叫 GIL （全局解释器锁） 的东西。</p>
<p>这就导致了 Python 的多个线程 其实 并不能同时使用 多个CPU核心。</p>
<p>所以如果是计算密集型的任务，不能采用多线程的方式。</p>
<p>大家可以运行一下如下代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="comment"># 启动10个线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Thread(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>



<p><img src="image-20230626195918984.png" alt="image-20230626195918984"></p>
<p>如果需要利用电脑多个CPU核心的运算能力，可以使用Python的多进程库，如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        p = Process(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>

<p>运行后，打开任务管理器，可以发现 有3个Python进程，其中主进程CPU占用率为0，两个子进程CPU各占满了一个核心的运算能力。</p>
<p><img src="image-20230626200335697.png" alt="image-20230626200335697"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统原理基础</title>
    <url>/2023/10/23/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>description：EXT文件系统的运行？与操作系统的文件数据有关。文件系统通常会将两部分的数据分别存放在不同的区块：权限与属性放置到inode中，至于实际数据则放置到 block区块中。 另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode与block的总量、使用量、剩余量等。每个 inode与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p>
<p>superblock：记录此 filesystem 的整体信息，包括 inode&#x2F;block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</p>
<p>inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码；</p>
<p>block：实际记录文件的内容，若文件太大时，会占用多个 block 。</p>
<span id="more"></span>

<h1 id="文件系统原理基础介绍"><a href="#文件系统原理基础介绍" class="headerlink" title="文件系统原理基础介绍"></a>文件系统原理基础介绍</h1><ul>
<li>inode<br>inode是ext文件系统中非常重要的概念，它记录了文件或目录的元数据信息，包括文件类型、文件大小、权限等。inode还包含了指向文件数据块的指针，因此可以快速访问文件的内容。在需要快速访问文件内容的场景下，使用ext文件系统可以提高文件系统的性能。例如，对于需要频繁读取大文件的应用程序，使用ext文件系统可以更快地访问文件内容，提高应用程序的响应速度。</li>
<li>block<br>块是ext文件系统中存储文件数据和文件系统本身元数据的基本单位，通常为4KB或8KB。文件数据和文件系统本身的元数据都存储在块中，因此块的大小会影响文件系统的性能。在需要存储大量大文件的场景下，使用较大的块可以提高文件系统的性能。例如，对于存储视频、音频等大文件的服务器，使用8KB块可以提高文件系统的读写速度。</li>
</ul>
<ol start="3">
<li>superblock<br>superblock是ext文件系统中存储文件系统元数据的特殊块，包括文件系统的大小、块大小、inode数量、 磁盘块分组信息等。superblock的信息可以帮助操作系统快速定位文件系统的元数据&amp;</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@euler ~]<span class="comment"># cp /etc/passwd .</span></span><br><span class="line">[root@euler ~]<span class="comment"># ls -lh passwd</span></span><br><span class="line">-rw-------. 1 root root 1.4K Oct 23 20:00 passwd</span><br><span class="line">[root@euler ~]<span class="comment"># du -sh passwd</span></span><br><span class="line">4.0K    passwd</span><br><span class="line">[root@euler ~]<span class="comment"># tune</span></span><br><span class="line">tune2fs    tuned      tuned-adm  tuned-gui</span><br><span class="line">[root@euler ~]<span class="comment"># tune</span></span><br><span class="line">tune2fs    tuned      tuned-adm  tuned-gui</span><br><span class="line"></span><br><span class="line">[root@euler ~]<span class="comment"># tune2fs -l /dev/sda1</span></span><br><span class="line">tune2fs 1.45.3 (14-Jul-2019)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          /boot</span><br><span class="line">Filesystem UUID:          7e9ed75d-b11b-4493-bf06-89366f29b087</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision <span class="comment">#:    1 (dynamic)</span></span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS <span class="built_in">type</span>:       Linux</span><br><span class="line">Inode count:              65536</span><br><span class="line">Block count:              262144</span><br><span class="line">Reserved block count:     13107</span><br><span class="line">Free blocks:              219154</span><br><span class="line">Free inodes:              65193</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096			<span class="comment"># 块大小</span></span><br><span class="line">Fragment size:            4096</span><br><span class="line">Group descriptor size:    64</span><br><span class="line">Reserved GDT blocks:      127</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8192</span><br><span class="line">Inode blocks per group:   512			</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Fri Sep  1 17:24:00 2023</span><br><span class="line">Last mount time:          Mon Oct 23 19:51:27 2023</span><br><span class="line">Last write time:          Mon Oct 23 19:51:27 2023</span><br><span class="line">Mount count:              21</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Fri Sep  1 17:24:00 2023</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          211 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:               256					<span class="comment"># Inode</span></span><br><span class="line">Required extra isize:     32</span><br><span class="line">Desired extra isize:      32</span><br><span class="line">Journal inode:            8</span><br><span class="line">Default directory <span class="built_in">hash</span>:   half_md4</span><br><span class="line">Directory Hash Seed:      1e814e07-4bbe-4847-976a-b67f3cb02a68</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Checksum <span class="built_in">type</span>:            crc32c</span><br><span class="line">Checksum:                 0xf1c73829</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@euler ~]<span class="comment"># ls -li passwd</span></span><br><span class="line">1308169 -rw-------. 1 root root 1386 Oct 23 20:00 passwd</span><br><span class="line">[root@euler ~]<span class="comment"># rm -f passwd</span></span><br><span class="line">[root@euler ~]<span class="comment"># touch newpasswd</span></span><br><span class="line">[root@euler ~]<span class="comment"># ls -li passwd</span></span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;passwd&#x27;</span>: No such file or directory</span><br><span class="line">[root@euler ~]<span class="comment"># ls -li newpasswd</span></span><br><span class="line">1308169 -rw-------. 1 root root 0 Oct 23 20:09 newpasswd</span><br><span class="line">[root@euler ~]<span class="comment"># echo hahaha &gt; newpasswd</span></span><br><span class="line">[root@euler ~]<span class="comment"># ls -ls newpasswd</span></span><br><span class="line">4 -rw-------. 1 root root 7 Oct 23 20:10 newpasswd</span><br><span class="line">[root@euler ~]<span class="comment"># ls -li newpasswd</span></span><br><span class="line">1308169 -rw-------. 1 root root 7 Oct 23 20:10 newpasswd</span><br><span class="line">[root@euler ~]<span class="comment"># dumpe2fs /dev/sda2 |more</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="superblock备份情况"><a href="#superblock备份情况" class="headerlink" title="superblock备份情况"></a>superblock备份情况</h2><p>超级快作用：记录文件系统的元数据（block iNode 等）</p>
<p>INode：记录文件的元数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Group 0: (Blocks 0-32767) csum 0x0f79 [ITABLE_ZEROED]</span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-1</span><br><span class="line">  Reserved GDT blocks at 2-128</span><br><span class="line">  Block bitmap at 129 (+129), csum 0x139a890b</span><br><span class="line">  Inode bitmap at 137 (+137), csum 0x1170712e</span><br><span class="line">  Inode table at 145-656 (+145)</span><br><span class="line">  28509 free blocks, 7851 free inodes, 10 directories, 7849 unused inodes</span><br><span class="line">  Free blocks: 4259-32767</span><br><span class="line">  Free inodes: 342-8192</span><br><span class="line">Group 1: (Blocks 32768-65535) csum 0x2033 [ITABLE_ZEROED]</span><br><span class="line">  Backup superblock at 32768, Group descriptors at 32769-32769</span><br><span class="line">  Reserved GDT blocks at 32770-32896</span><br><span class="line">  Block bitmap at 130 (<span class="built_in">bg</span> <span class="comment">#0 + 130), csum 0xa5614c8d</span></span><br><span class="line">  Inode bitmap at 138 (<span class="built_in">bg</span> <span class="comment">#0 + 138), csum 0x72b581cd</span></span><br><span class="line">  Inode table at 657-1168 (<span class="built_in">bg</span> <span class="comment">#0 + 657)</span></span><br><span class="line">  7608 free blocks, 8190 free inodes, 2 directories, 8190 unused inodes</span><br><span class="line">  Free blocks: 35886-35903, 35929-35935, 35958-35967, 36014-36031, 36082-36351, 36550-36863,</span><br><span class="line"> 37370-37375, 37840-37887, 38514-38911, 42925-42943, 42982-43007, 55228-55231, 55274-55295,</span><br><span class="line">55298-59391, 59393-61055, 61103-61119, 61158-61439, 65144-65535</span><br><span class="line">  Free inodes: 8195-16384</span><br><span class="line">Group 2: (Blocks 65536-98303) csum 0xed9c [INODE_UNINIT, ITABLE_ZEROED]</span><br><span class="line">  Block bitmap at 131 (<span class="built_in">bg</span> <span class="comment">#0 + 131), csum 0x87d4ae31</span></span><br><span class="line">  Inode bitmap at 139 (<span class="built_in">bg</span> <span class="comment">#0 + 139), csum 0x00000000</span></span><br><span class="line">  Inode table at 1169-1680 (<span class="built_in">bg</span> <span class="comment">#0 + 1169)</span></span><br><span class="line">  27776 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes</span><br><span class="line">  Free blocks: 65536-67583, 72576-98303</span><br><span class="line">  Free inodes: 16385-24576</span><br><span class="line">Group 3: (Blocks 98304-131071) csum 0x3f8e [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]</span><br><span class="line">  Backup superblock at 98304, Group descriptors at 98305-98305</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="用备份superblock修复"><a href="#用备份superblock修复" class="headerlink" title="用备份superblock修复"></a>用备份superblock修复</h1><h2 id="fsck-ext4"><a href="#fsck-ext4" class="headerlink" title="fsck			-&gt; ext4"></a>fsck			-&gt; ext4</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@euler ~]<span class="comment"># cd /data/</span></span><br><span class="line">[root@euler data]<span class="comment"># ls</span></span><br><span class="line">lost+found</span><br><span class="line">[root@euler data]<span class="comment"># cp /etc/passwd .</span></span><br><span class="line">[root@euler data]<span class="comment"># ls</span></span><br><span class="line">lost+found  passwd</span><br><span class="line">[root@euler data]<span class="comment"># umount /data/</span></span><br><span class="line">umount: /data/: target is busy.</span><br><span class="line">[root@euler data]<span class="comment"># df -h</span></span><br><span class="line">Filesystem                  Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                    1.7G     0  1.7G   0% /dev</span><br><span class="line">tmpfs                       1.7G     0  1.7G   0% /dev/shm</span><br><span class="line">tmpfs                       1.7G  1.1M  1.7G   1% /run</span><br><span class="line">tmpfs                       1.7G     0  1.7G   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/openeuler-root   35G  4.6G   28G  14% /</span><br><span class="line">tmpfs                       1.7G     0  1.7G   0% /tmp</span><br><span class="line">/dev/sda1                   976M  120M  789M  14% /boot</span><br><span class="line">tmpfs                       341M     0  341M   0% /run/user/0</span><br><span class="line">/dev/sdb1                   7.9G   36M  7.4G   1% /data</span><br><span class="line">[root@euler data]<span class="comment"># cd</span></span><br><span class="line">[root@euler ~]<span class="comment"># umount /data/</span></span><br><span class="line">[root@euler ~]<span class="comment"># dd if=/dev/zero of=/dev/sdb1 bs=4k count=10</span></span><br><span class="line">10+0 records <span class="keyword">in</span></span><br><span class="line">10+0 records out</span><br><span class="line">40960 bytes (41 kB, 40 KiB) copied, 0.000255767 s, 160 MB/s</span><br><span class="line">[root@euler ~]<span class="comment"># mount /dev/sdb1 /data/</span></span><br><span class="line">mount: /data: unknown filesystem <span class="built_in">type</span>.</span><br><span class="line">[root@euler ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem                  Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                    1.7G     0  1.7G   0% /dev</span><br><span class="line">tmpfs                       1.7G     0  1.7G   0% /dev/shm</span><br><span class="line">tmpfs                       1.7G  1.1M  1.7G   1% /run</span><br><span class="line">tmpfs                       1.7G     0  1.7G   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/openeuler-root   35G  4.6G   28G  14% /</span><br><span class="line">tmpfs                       1.7G     0  1.7G   0% /tmp</span><br><span class="line">/dev/sda1                   976M  120M  789M  14% /boot</span><br><span class="line">tmpfs                       341M     0  341M   0% /run/user/0</span><br><span class="line">[root@euler ~]<span class="comment"># mount /dev/sdb1 /data/</span></span><br><span class="line">mount: /data: unknown filesystem <span class="built_in">type</span>.</span><br><span class="line">[root@euler ~]<span class="comment"># fsck :filesystem check^C</span></span><br><span class="line">[root@euler ~]<span class="comment"># fsck -v /dev/sdb1</span></span><br><span class="line">fsck from util-linux 2.34</span><br><span class="line">e2fsck 1.45.3 (14-Jul-2019)</span><br><span class="line">ext2fs_open2: Bad magic number <span class="keyword">in</span> super-block</span><br><span class="line">fsck.ext2: Superblock invalid, trying backup blocks...</span><br><span class="line">/dev/sdb1 was not cleanly unmounted, check forced.</span><br><span class="line">Resize inode not valid.  Recreate&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">Block bitmap differences:  +(98304--99328) +(163840--164864) +(229376--230400) +(294912--295936) +(819200--820224) +(884736--885760) +(1605632--1606656)</span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Free blocks count wrong <span class="keyword">for</span> group <span class="comment">#0 (23512, counted=23513).</span></span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Free blocks count wrong <span class="keyword">for</span> group <span class="comment">#1 (31743, counted=31742).</span></span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Free inodes count wrong <span class="keyword">for</span> group <span class="comment">#0 (8181, counted=8180).</span></span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Free inodes count wrong (524277, counted=524276).</span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Padding at end of inode bitmap is not <span class="built_in">set</span>. Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">/dev/sdb1: ***** FILE SYSTEM WAS MODIFIED *****</span><br><span class="line"></span><br><span class="line">          12 inodes used (0.00%, out of 524288)</span><br><span class="line">           0 non-contiguous files (0.0%)</span><br><span class="line">           0 non-contiguous directories (0.0%)</span><br><span class="line">             <span class="comment"># of inodes with ind/dind/tind blocks: 0/0/0</span></span><br><span class="line">             Extent depth histogram: 4</span><br><span class="line">       58512 blocks used (2.79%, out of 2096896)</span><br><span class="line">           0 bad blocks</span><br><span class="line">           0 large files</span><br><span class="line"></span><br><span class="line">           1 regular file</span><br><span class="line">           2 directories</span><br><span class="line">           0 character device files</span><br><span class="line">           0 block device files</span><br><span class="line">           0 fifos</span><br><span class="line">           0 links</span><br><span class="line">           0 symbolic links (0 fast symbolic links)</span><br><span class="line">           0 sockets</span><br><span class="line">------------</span><br><span class="line">           3 files</span><br><span class="line">[root@euler ~]<span class="comment"># mount /dev/sdb1 /data/</span></span><br><span class="line">[root@euler ~]<span class="comment"># LS</span></span><br><span class="line">-bash: LS: <span class="built_in">command</span> not found</span><br><span class="line">[root@euler ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg  gauss_om  newpasswd</span><br><span class="line">[root@euler ~]<span class="comment"># cd /data/</span></span><br><span class="line">[root@euler data]<span class="comment"># ls</span></span><br><span class="line">lost+found  passwd</span><br></pre></td></tr></table></figure>



<h2 id="e2fsck"><a href="#e2fsck" class="headerlink" title="e2fsck"></a>e2fsck</h2><h2 id="利用后面的超级块位置"><a href="#利用后面的超级块位置" class="headerlink" title="利用后面的超级块位置"></a>利用后面的超级块位置</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@euler ~]<span class="comment"># dumpe2fs /dev/sda1 |more</span></span><br><span class="line"></span><br><span class="line">Group 3: (Blocks 98304-131071) csum 0x3f8e [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]</span><br><span class="line">  Backup superblock at 98304, Group descriptors at 98305-98305</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@euler data]<span class="comment"># ls</span></span><br><span class="line">lost+found  passwd</span><br><span class="line">[root@euler data]<span class="comment"># cd</span></span><br><span class="line">[root@euler ~]<span class="comment"># umount /data/</span></span><br><span class="line">[root@euler ~]<span class="comment"># dd if=/dev/zero of=/dev/sdb1 bs=4k count=10</span></span><br><span class="line">10+0 records <span class="keyword">in</span></span><br><span class="line">10+0 records out</span><br><span class="line">40960 bytes (41 kB, 40 KiB) copied, 0.00033505 s, 122 MB/s</span><br><span class="line">[root@euler ~]<span class="comment"># mount /dev/sdb</span></span><br><span class="line">sdb   sdb1</span><br><span class="line">[root@euler ~]<span class="comment"># mount /dev/sdb1 /data/</span></span><br><span class="line">mount: /data: unknown filesystem <span class="built_in">type</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@euler ~]<span class="comment"># e2fsck -b 98304 /dev/sdb1</span></span><br><span class="line">e2fsck 1.45.3 (14-Jul-2019)</span><br><span class="line">/dev/sdb1 was not cleanly unmounted, check forced.</span><br><span class="line">Resize inode not valid.  Recreate&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">esPass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">Free blocks count wrong <span class="keyword">for</span> group <span class="comment">#0 (23512, counted=23513).</span></span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Free blocks count wrong <span class="keyword">for</span> group <span class="comment">#1 (31743, counted=31742).</span></span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Free inodes count wrong <span class="keyword">for</span> group <span class="comment">#0 (8181, counted=8180).</span></span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Free inodes count wrong (524277, counted=524276).</span><br><span class="line">Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line">Padding at end of inode bitmap is not <span class="built_in">set</span>. Fix&lt;y&gt;? <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">/dev/sdb1: ***** FILE SYSTEM WAS MODIFIED *****</span><br><span class="line">/dev/sdb1: 12/524288 files (0.0% non-contiguous), 58512/2096896 blocks</span><br><span class="line">[root@euler ~]<span class="comment"># mount /dev/sdb1 /data/</span></span><br><span class="line">[root@euler ~]<span class="comment"># ls /data/</span></span><br><span class="line">lost+found  passwd</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dd = device-to-device if=input file of=outfile file bs=block size count</span></span><br><span class="line">[root@euler ~]<span class="comment"># dd if=/dev/zero of=/dev/sdb1 bs=4k count=10</span></span><br><span class="line">10+0 records <span class="keyword">in</span></span><br><span class="line">10+0 records out</span><br><span class="line">40960 bytes (41 kB, 40 KiB) copied, 0.00033505 s, 122 MB/s</span><br><span class="line"><span class="comment"># 输入密码 然后fsck -v -y /dev/sdb1  		# 启动时会提示故障磁盘位置</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20231023205424788.png" alt="image-20231023205424788"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title>私有Harbor仓库搭建实战</title>
    <url>/2023/10/24/%E7%A7%81%E6%9C%89Harbor%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>Description：</p>
<p>部署企业私有仓库往往是很有必要的, 它可以帮助你管理企业的一些敏感镜像同时由于Docker Hub的下载速度和GFW的原因, 往往需要将一些无法直接下载的镜像导入本地私有仓库而Harbor就是部署企业私有仓库的一个不二之选。</p>
<span id="more"></span>

<h1 id="harbor搭建实战"><a href="#harbor搭建实战" class="headerlink" title="harbor搭建实战"></a>harbor搭建实战</h1><h2 id="关闭防火墙和selinux"><a href="#关闭防火墙和selinux" class="headerlink" title="关闭防火墙和selinux"></a>关闭防火墙和selinux</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># systemctl stop firewalld.service</span></span><br><span class="line">[root@docker01 ~]<span class="comment"># systemctl disable firewalld.service</span></span><br><span class="line">Removed /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="line">Removed /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">[root@docker01 ~]<span class="comment"># systemctl status firewalld.service</span></span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead) since Mon 2023-08-14 13:15:54 CST; 2min 7s ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 847 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.24.150 docker01</span><br><span class="line">[root@docker01 ~]<span class="comment"># ping docker01</span></span><br><span class="line">PING docker01 (192.168.24.150) 56(84) bytes of data.</span><br><span class="line">64 bytes from docker01 (192.168.24.150): icmp_seq=1 ttl=64 time=0.028 ms</span><br><span class="line">64 bytes from docker01 (192.168.24.150): icmp_seq=2 ttl=64 time=0.032 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="harbor"><a href="#harbor" class="headerlink" title="harbor"></a>harbor</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ls</span></span><br><span class="line"> 02-bridge-utils-1.5-9.el7.x86_64.rpm     anaconda-ks.cfg  <span class="string">&#x27;MYSQL_DATABASE=wordpress&#x27;</span></span><br><span class="line"> 03-harbor-offline-installer-v2.7.1.tgz   dockerfile        nginx.txt</span><br><span class="line">[root@docker01 ~]<span class="comment"># tar -zxvf 03-harbor-offline-installer-v2.7.1.tgz</span></span><br><span class="line">harbor/harbor.v2.7.1.tar.gz</span><br><span class="line">harbor/prepare</span><br><span class="line">harbor/LICENSE</span><br><span class="line">harbor/install.sh</span><br><span class="line">harbor/common.sh</span><br><span class="line">harbor/harbor.yml.tmpl</span><br><span class="line">[root@docker01 ~]<span class="comment"># cd harbor/</span></span><br><span class="line">[root@docker01 harbor]<span class="comment"># ls</span></span><br><span class="line">common.sh  harbor.v2.7.1.tar.gz  harbor.yml.tmpl  install.sh  LICENSE  prepare</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>harbor.yml</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hostname: docker01</span><br><span class="line"></span><br><span class="line"><span class="comment"># http related config</span></span><br><span class="line">http:</span><br><span class="line">  <span class="comment"># port for http, default is 80. If https enabled, this port will redirect to https port</span></span><br><span class="line">  port: 5868</span><br><span class="line"></span><br><span class="line"><span class="comment"># https related config</span></span><br><span class="line"><span class="comment">#https:</span></span><br><span class="line">  <span class="comment"># https port for harbor, default is 443</span></span><br><span class="line">  <span class="comment"># port: 443</span></span><br><span class="line">  <span class="comment"># The path of cert and key files for nginx</span></span><br><span class="line">  <span class="comment">#certificate: /your/certificate/path</span></span><br><span class="line">  <span class="comment">#private_key: /your/private/key/path</span></span><br><span class="line"></span><br><span class="line">harbor_admin_password: Harbor</span><br><span class="line"></span><br><span class="line"><span class="comment"># Harbor DB configuration</span></span><br><span class="line">database:</span><br><span class="line">  <span class="comment"># The password for the root user of Harbor DB. Change this before any production use.</span></span><br><span class="line">   password: root</span><br><span class="line">  <span class="comment"># The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained.</span></span><br><span class="line">  max_idle_conns: 100</span><br><span class="line">  <span class="comment"># The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections.</span></span><br><span class="line">  <span class="comment"># Note: the default number of connections is 1024 for postgres of harbor.</span></span><br><span class="line">  max_open_conns: 900</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="docker-service"><a href="#docker-service" class="headerlink" title="docker.service"></a>docker.service</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="comment"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class="line"><span class="comment"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class="line"><span class="comment"># for containers run by docker</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry=192.168.24.150:5868</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 system]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@docker01 system]<span class="comment"># systemctl restart docker.service</span></span><br><span class="line">[root@docker01 system]<span class="comment"># systemctl status docker</span></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2023-08-14 13:30:18 CST; 10s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 2719 (dockerd)</span><br><span class="line">    Tasks: 9</span><br><span class="line">   Memory: 28.2M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─2719 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry=192.168.24.150:5868</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>prepare</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker01 harbor]# ./prepare</span><br><span class="line">prepare base dir is set to /root/harbor</span><br><span class="line">Unable to find image &#x27;goharbor/prepare:v2.7.1&#x27; locally</span><br><span class="line">v2.7.1: Pulling from goharbor/prepare</span><br><span class="line">e8f9c57a1510: Pull complete</span><br><span class="line">[root@docker01 harbor]# ls</span><br><span class="line">common  common.sh  docker-compose.yml  harbor.v2.7.1.tar.gz  harbor.yml  harbor.yml.tmpl  install.sh  LICENSE  prepare</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>common.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">119         <span class="keyword">elif</span> [[ $(docker compose version) =~ (([<span class="number">0</span>-<span class="number">9</span>]+)\.([<span class="number">0</span>-<span class="number">9</span>]+)([\.<span class="number">0</span>-<span class="number">9</span>]*)) ]]</span><br></pre></td></tr></table></figure>

<p>install.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">26 DOCKER_COMPOSE=<span class="string">&quot;docker compose&quot;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 harbor]<span class="comment"># ls</span></span><br><span class="line">common  common.sh  docker-compose.yml  harbor.v2.7.1.tar.gz  harbor.yml  harbor.yml.tmpl  install.sh  LICENSE  prepare</span><br><span class="line">[root@docker01 harbor]<span class="comment"># ./install.sh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 harbor]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                      TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">centos                          v1.0       d153060d7264   15 hours ago    307MB</span><br><span class="line">goharbor/harbor-exporter        v2.7.1     d40eb452ec72   5 months ago    96.5MB</span><br><span class="line">goharbor/chartmuseum-photon     v2.7.1     e6ab349a4f12   5 months ago    227MB</span><br><span class="line">goharbor/redis-photon           v2.7.1     229dd1844a26   5 months ago    127MB</span><br><span class="line">goharbor/trivy-adapter-photon   v2.7.1     729fab8418df   5 months ago    442MB</span><br><span class="line">goharbor/notary-server-photon   v2.7.1     12adb40b7a3b   5 months ago    113MB</span><br><span class="line">goharbor/notary-signer-photon   v2.7.1     f114329e0165   5 months ago    110MB</span><br><span class="line">goharbor/harbor-registryctl     v2.7.1     9b2219d529c8   5 months ago    140MB</span><br><span class="line">goharbor/registry-photon        v2.7.1     9d50b10d3700   5 months ago    78.1MB</span><br><span class="line">goharbor/nginx-photon           v2.7.1     e98018335c0d   5 months ago    126MB</span><br><span class="line">goharbor/harbor-log             v2.7.1     eeb93d98a358   5 months ago    133MB</span><br><span class="line">goharbor/harbor-jobservice      v2.7.1     829d13e6aae7   5 months ago    252MB</span><br><span class="line">goharbor/harbor-core            v2.7.1     49d6c8a15d6c   5 months ago    215MB</span><br><span class="line">goharbor/harbor-portal          v2.7.1     fe05b1b0bcfd   5 months ago    135MB</span><br><span class="line">goharbor/harbor-db              v2.7.1     b3f8d9d6c213   5 months ago    174MB</span><br><span class="line">goharbor/prepare                v2.7.1     d9e019294af2   5 months ago    164MB</span><br><span class="line">nginx                           latest     605c77e624dd   19 months ago   141MB</span><br><span class="line">wordpress                       latest     c3c92cc3dcb1   19 months ago   616MB</span><br><span class="line">mysql                           5.7        c20987f18b13   20 months ago   448MB</span><br><span class="line">alpine                          latest     c059bfaa849c   20 months ago   5.59MB</span><br><span class="line">minlinux                        v1.0       c059bfaa849c   20 months ago   5.59MB</span><br><span class="line">centos                          8.4.2105   5d0da3dc9764   23 months ago   231MB</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 harbor]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE                                COMMAND                  CREATED         STATUS                   PORTS                                       NAMES</span><br><span class="line">d6faa6ce7970   goharbor/harbor-jobservice:v2.7.1    <span class="string">&quot;/harbor/entrypoint.…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)                                               harbor-jobservice</span><br><span class="line">16529700cc52   goharbor/nginx-photon:v2.7.1         <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)   0.0.0.0:5868-&gt;8080/tcp, :::5868-&gt;8080/tcp   nginx</span><br><span class="line">574af227cfa4   goharbor/harbor-core:v2.7.1          <span class="string">&quot;/harbor/entrypoint.…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)                                               harbor-core</span><br><span class="line">42e87f7ae75c   goharbor/harbor-db:v2.7.1            <span class="string">&quot;/docker-entrypoint.…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)                                               harbor-db</span><br><span class="line">10c09b0ea4b1   goharbor/harbor-portal:v2.7.1        <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)                                               harbor-portal</span><br><span class="line">a5e718011267   goharbor/registry-photon:v2.7.1      <span class="string">&quot;/home/harbor/entryp…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)                                               registry</span><br><span class="line">d4c68186fdc5   goharbor/harbor-registryctl:v2.7.1   <span class="string">&quot;/home/harbor/start.…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)                                               registryctl</span><br><span class="line">6b50b79c669b   goharbor/redis-photon:v2.7.1         <span class="string">&quot;redis-server /etc/r…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)                                               redis</span><br><span class="line">2c1b14870116   goharbor/harbor-log:v2.7.1           <span class="string">&quot;/bin/sh -c /usr/loc…&quot;</span>   9 minutes ago   Up 9 minutes (healthy)   127.0.0.1:1514-&gt;10514/tcp                   harbor-log</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="管理使用"><a href="#管理使用" class="headerlink" title="管理使用"></a>管理使用</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 harbor]<span class="comment"># docker push 192.168.24.150:5868/test/mliunx:v</span></span><br><span class="line">The push refers to repository [192.168.24.150:5868/test/mliunx]</span><br><span class="line">An image does not exist locally with the tag: 192.168.24.150:5868/test/mliunx</span><br><span class="line">[root@docker01 harbor]<span class="comment"># docker tag alpine:latest  192.168.24.150:5868/test/mliunx:v</span></span><br><span class="line">[root@docker01 harbor]<span class="comment"># docker push 192.168.24.150:5868/test/mliunx:v</span></span><br><span class="line">The push refers to repository [192.168.24.150:5868/test/mliunx]</span><br><span class="line">8d3ac3489996: Pushed</span><br><span class="line">v: digest: sha256:e7d88de73db3d3fd9b2d63aa7f447a10fd0220b7cbf39803c803f2af9ba256b3 size: 528</span><br></pre></td></tr></table></figure>

<p><img src="image-20230814140548784-16946962612661.png" alt="image-20230814140548784"></p>
<p>pull</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 harbor]<span class="comment"># docker pull 192.168.24.150:5868/test/mliunx:v</span></span><br><span class="line">v: Pulling from <span class="built_in">test</span>/mliunx</span><br><span class="line">Digest: sha256:e7d88de73db3d3fd9b2d63aa7f447a10fd0220b7cbf39803c803f2af9ba256b3</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 192.168.24.150:5868/test/mliunx:v</span><br><span class="line">192.168.24.150:5868/test/mliunx:v</span><br><span class="line">[root@docker01 harbor]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                        TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">centos                            v1.0       d153060d7264   16 hours ago    307MB</span><br><span class="line">goharbor/harbor-exporter          v2.7.1     d40eb452ec72   5 months ago    96.5MB</span><br><span class="line"></span><br><span class="line">192.168.24.150:5868/test/mliunx   v          c059bfaa849c   20 months ago   5.59MB</span><br><span class="line">alpine                            latest     c059bfaa849c   20 months ago   5.59MB</span><br><span class="line">minlinux                          v1.0       c059bfaa849c   20 months ago   5.59MB</span><br><span class="line">centos                            8.4.2105   5d0da3dc9764   23 months ago   231MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@docker01 harbor]<span class="comment"># docker run -it --name mlinux 192.168.24.150:5868/test/mliunx:v</span></span><br><span class="line">/ <span class="comment"># ip a |grep veth</span></span><br><span class="line">/ <span class="comment"># ip a |grep eth</span></span><br><span class="line">37: eth0@if38: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">/ <span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.baidu.com (182.61.200.7): 56 data bytes</span><br><span class="line">64 bytes from 182.61.200.7: <span class="built_in">seq</span>=0 ttl=127 time=39.340 ms</span><br><span class="line">^C</span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line">1 packets transmitted, 1 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 39.340/39.340/39.340 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础</title>
    <url>/2023/10/18/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>摘要:   Python的Socket编程是指使用Python语言进行网络编程，使用的基础是Socket库。这个库提供了与底层操作系统套接字接口几乎相同的接口，使得Python开发者可以像使用C语言一样对网络数据流进行操作。</p>
<span id="more"></span>

<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="C-S架构与B-S架构"><a href="#C-S架构与B-S架构" class="headerlink" title="C&#x2F;S架构与B&#x2F;S架构"></a>C&#x2F;S架构与B&#x2F;S架构</h3><p>c&#x2F;s架构  client&#x2F;server<br>b&#x2F;s架构  browser（浏览器）&#x2F;server</p>
<p>web1.0 纯静态页面，不能交互html文档<br>web2.0 支持用户上传信息，交互，购物 网站后台：ruby java perl php python<br>web3.0 移动互联网时代 衣食住行 出门只带个手机 网站后台:java php python go</p>
<h3 id="半链接池"><a href="#半链接池" class="headerlink" title="半链接池"></a>半链接池</h3><p>假设同一时间有多个请求从客户端发送到服务端，服务端不会全部把这些请求加载到内存中，</p>
<p>而是会根据半链接池的容量将这些请求放在半链接池中。由于此时只是访问的请求，并不是一个完整的链接，因此叫做半链接。</p>
<p>因此如果遇到洪水攻击，需要减少半链接池的容量。</p>
<h2 id="Socket模块"><a href="#Socket模块" class="headerlink" title="Socket模块"></a>Socket模块</h2><h3 id="Socket（套接字）简介"><a href="#Socket（套接字）简介" class="headerlink" title="Socket（套接字）简介"></a>Socket（套接字）简介</h3><p>如果正常情况下，当我们开发了应用程序后，数据需要根据网络模型逐层完成封装才能发送出去。如果这些封装都由自己来完成，那么必须十分清楚每一层的协议的各个字段，并且很清晰的了解封装的方法才能最终将数据发送出去。</p>
<p>而在真实做程序开发时，可以理解为应用层与传输层之间，还夹杂了一层socket抽象层，也叫作套接字。</p>
<p>借助于该抽象层，我们在应用层产生的所有数据只要通过socket开放的接口丢给socket，那么socket就会自动的对该数据去完成封装。同时对于收到的数据，也可以解封装后交给应用程序。因此套接字封装的是传输层及以下</p>
<p>python当中也提供了socket模块</p>
<p>应用层产生数据，作为开发者，不需要关注每一层具体是如何完成封装的，而是直接讲数据丢给socket模块的接口，由socket逻辑抽象层自动的完成封装</p>
<h3 id="基于tcp协议的套接字通信"><a href="#基于tcp协议的套接字通信" class="headerlink" title="基于tcp协议的套接字通信"></a>基于tcp协议的套接字通信</h3><h4 id="基本通信"><a href="#基本通信" class="headerlink" title="基本通信"></a>基本通信</h4><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line">conn, client_addr = server.accept()</span><br><span class="line"><span class="comment"># 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line">data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># 7. 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息:&quot;</span>)</span><br><span class="line">client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># 4. 收信息</span></span><br><span class="line">res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<h4 id="通信循环"><a href="#通信循环" class="headerlink" title="通信循环"></a>通信循环</h4><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"></span><br><span class="line">conn, client_addr = server.accept()</span><br><span class="line">    <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">    <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">    conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># # 7. 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息(q/Q退出):&quot;</span>)</span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>



<h4 id="BUG修正"><a href="#BUG修正" class="headerlink" title="BUG修正"></a>BUG修正</h4><ol>
<li>当客户端发送给服务端的信息为空时,此时服务端会一直等待从自身的缓存当中拿到数据，因此程序会出现卡壳的现象</li>
</ol>
<p>tips:在进行网络编程时，客户调和服务端使用send和recv方法来发送和接收数据时，从基本角度来说并不是跟对方打交道，而是跟自身的缓存打交道</p>
<ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"></span><br><span class="line">conn, client_addr = server.accept()</span><br><span class="line">    <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">    <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">    conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># # 7. 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>如果客户端断开连接，此时服务端会卡在接收信息的地方</li>
</ul>
<p>server</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;客户端发来的信息为%s&quot;</span>%data)</span><br><span class="line">        <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">break</span>   <span class="comment">#通过这一步来解决客户端意外断开连接的情况</span></span><br><span class="line">        <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br></pre></td></tr></table></figure>



<h4 id="链接循环"><a href="#链接循环" class="headerlink" title="链接循环"></a>链接循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="验证半链接池"><a href="#验证半链接池" class="headerlink" title="验证半链接池"></a>验证半链接池</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>



<h3 id="基于udp协议的套接字通信"><a href="#基于udp协议的套接字通信" class="headerlink" title="基于udp协议的套接字通信"></a>基于udp协议的套接字通信</h3><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个基于UDP套接字通信的服务端</span></span><br><span class="line">server = socket(AF_INET, SOCK_DGRAM) </span><br><span class="line"><span class="comment"># 服务端绑定IP和端口信息</span></span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 设定最大接收字节数，recvfrom返回值是一个元组，分别是接收到的数据和客户端的ip以及端口信息</span></span><br><span class="line">data_info,client_addr = server.recvfrom(<span class="number">1024</span>)</span><br><span class="line">res = data_info.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">result = res+res</span><br><span class="line"><span class="built_in">print</span>(client_addr)</span><br><span class="line"><span class="comment"># 发送数据，同时需要指定客户端的ip和端口信息</span></span><br><span class="line">server.sendto(result.encode(<span class="string">&quot;utf-8&quot;</span>),client_addr)</span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个基于UDP套接字通信的客户端</span></span><br><span class="line">client = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入一段内容:&quot;</span>).strip()</span><br><span class="line"><span class="comment"># 发送数据，同时需要指定服务端的ip和端口信息</span></span><br><span class="line">client.sendto(user_input.encode(<span class="string">&quot;utf-8&quot;</span>),(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 设定接收最大字节数，recvfrom返回的是数据+服务端ip和端口的信息</span></span><br><span class="line">res, server_addr= client.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(res.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><h3 id="什么是粘包？"><a href="#什么是粘包？" class="headerlink" title="什么是粘包？"></a>什么是粘包？</h3><ul>
<li>补充subprocess模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">    obj = subprocess.Popen(args=cmd,</span><br><span class="line">                           shell=<span class="literal">True</span>,</span><br><span class="line">                           stdout=subprocess.PIPE,</span><br><span class="line">                           stderr=subprocess.PIPE</span><br><span class="line">    )</span><br><span class="line">    std_out = obj.stdout.read()</span><br><span class="line">    std_err = obj.stderr.read()</span><br><span class="line">    result = (std_out+std_err).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>



<p>对于TCP协议而言，recv和send本质上都是与自身的缓存打交道，send就是将缓存当中的数据发送出去，而recv就是根据设置的接收最大字节数从缓存中取出该长度的数据</p>
<p>在执行不同的命令时，所得到的回显结果是没有边界感的，所有的数据都粘在一起，这就是TCP的粘包现象</p>
<ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        obj = subprocess.Popen(args=cmd,</span><br><span class="line">                               shell=<span class="literal">True</span>,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE</span><br><span class="line">                               )</span><br><span class="line">        std_out = obj.stdout.read()</span><br><span class="line">        std_err = obj.stderr.read()</span><br><span class="line">        result = std_out + std_err</span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="如何解决粘包"><a href="#如何解决粘包" class="headerlink" title="如何解决粘包"></a>如何解决粘包</h3><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        obj = subprocess.Popen(args=cmd,</span><br><span class="line">                               shell=<span class="literal">True</span>,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE</span><br><span class="line">                               )</span><br><span class="line">        std_out = obj.stdout.read()</span><br><span class="line">        std_err = obj.stderr.read()</span><br><span class="line">        result = std_out + std_err</span><br><span class="line">        total_size = struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(result))</span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(total_size)</span><br><span class="line">        conn.send(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    total_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, client.recv(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> size &lt; total_size:</span><br><span class="line">        res += client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">        size += <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>网络自动化模块paramiko</title>
    <url>/2023/10/18/%E7%BD%91%E7%BB%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A8%A1%E5%9D%97paramiko/</url>
    <content><![CDATA[<p>介绍：Paramiko是基于Python实现的SSH2远程安全连接，支持认证及密钥方式，可实现远程命令执行、文件传输、中间SSH代理等功能。</p>
<p>通俗的讲:Python的Paramiko依赖库，可以帮助开发者通过代码的方式完成对远程服务器的文件上传、文件下载操作，也可以对远程服务器输入操作命令。</p>
<span id="more"></span>





<h1 id="网络自动化相关模块"><a href="#网络自动化相关模块" class="headerlink" title="网络自动化相关模块"></a>网络自动化相关模块</h1><h1 id="paramiko基础"><a href="#paramiko基础" class="headerlink" title="paramiko基础"></a>paramiko基础</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt;system-view immediately </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[HUAWEI]</span><br><span class="line">-----------------</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种方式打开SSH会话通道</span></span><br><span class="line"><span class="comment"># 1.transport</span></span><br><span class="line"><span class="comment"># 2.SSHclient(集成了transport)</span></span><br><span class="line"></span><br><span class="line">ssh_client = paramiko.SSHClient()</span><br><span class="line">ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 默认使用账号密码进行用户认证时，需要先获取服务器的公钥，服务器将公钥发送给客户端时，客户端默认不会立即接收该公钥</span></span><br><span class="line"><span class="comment"># 而set_missing_host_key_policy(paramiko.AutoAddPolicy())的作用就是让我们可以不输入yes or no的情况下自动把公钥保存在本地</span></span><br><span class="line">ssh_client.connect(hostname=<span class="string">&quot;192.168.100.1&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">vty = ssh_client.invoke_shell()</span><br><span class="line">res = vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&quot;N\n&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line">res = vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&quot;screen-length 0 temporary\n&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line">vty.send(<span class="string">&quot;dis cu\n&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">res = vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h1 id="SFTP基础"><a href="#SFTP基础" class="headerlink" title="SFTP基础"></a>SFTP基础</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>第一种方式</span><br><span class="line"><span class="comment"># 2. 使用transport打开SSH会话通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tran = paramiko.Transport((&quot;192.168.100.1&quot;, 22))</span></span><br><span class="line"><span class="comment"># tran.connect(username=&quot;python&quot;, password=&quot;Huawei@123&quot;)</span></span><br><span class="line"><span class="comment"># sftp = paramiko.SFTPClient.from_transport(tran)  # 从SSH会话的通道中建立sftp会话的通道</span></span><br><span class="line"><span class="comment"># sftp.get(&quot;/vrpcfg.cfg&quot;, r&quot;E:\devops\pythonProject\CE1.cfg&quot;)</span></span><br><span class="line"><span class="comment"># sftp.put(r&quot;E:\devops\pythonProject\CE1.cfg&quot;, &quot;/TEST.cfg&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在执行sftp get下载时，如果下载后的名称相同，后面下载的文件会将前面下载的文件覆盖掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cfcard:/vrpcfg.cfg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：在写路径时不要敲额外的字符，否则会报文件不存在的错误</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>第二种方式</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transport</span>():</span><br><span class="line">    ssh_session = paramiko.SSHClient()</span><br><span class="line">    <span class="comment"># 在使用口令认证进行ssh连接时，客户端会先向请求服务端的公钥，这一条命令的作用就是</span></span><br><span class="line">    <span class="comment"># 让我们在不输入yes/no的情况下将服务端的公钥保存在本地</span></span><br><span class="line">    ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_session.connect(hostname=<span class="string">&quot;192.168.100.1&quot;</span>,port=<span class="number">22</span>,username=<span class="string">&quot;python&quot;</span>,password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">    <span class="comment"># 在ssh会话通道的基础上，打开命令行交互的通道</span></span><br><span class="line">    <span class="keyword">return</span> ssh_session</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    tran = transport()</span><br><span class="line">    res = tran.get_transport()</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(res)</span><br><span class="line">    <span class="comment"># get方法，将远程的文件下载到本地：remotepath localpath</span></span><br><span class="line">    remote = <span class="string">&quot;/vrpcfg.cfg&quot;</span></span><br><span class="line">    local = <span class="string">r&quot;E:\devops\Phase 2\project\自动化编程\自动化相关模块\CE2.txt&quot;</span></span><br><span class="line">    <span class="comment"># sftp.get(remote,local)</span></span><br><span class="line">    remote_put = <span class="string">&quot;CE1.cfg&quot;</span></span><br><span class="line">    <span class="comment"># sftp.put(local,remote_put)</span></span><br><span class="line">    sftp.get(remote,local)</span><br><span class="line">    sftp.close()</span><br></pre></td></tr></table></figure>



<h1 id="补充-OS模块"><a href="#补充-OS模块" class="headerlink" title="补充 OS模块"></a>补充 OS模块</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path_dirs = <span class="string">&quot;files&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path_dirs):</span><br><span class="line">    os.makedirs(path_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># path = os.path.abspath(__file__)  # 获取当前py文件的绝对路径</span></span><br><span class="line"><span class="comment"># root_path = os.path.dirname(path)  # 获取path路径的上一级目录</span></span><br><span class="line"><span class="comment"># new_path = os.path.join(root_path, &quot;files&quot;)  # 实现路径的拼接,将root_path 与 files进行路径的拼接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path)</span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.使用os模块来获取当前执行文件的绝对路径</span></span><br><span class="line">v1 = os.path.abspath(__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用os模块来获取上一级的目录</span></span><br><span class="line">v2 = os.path.dirname(v1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用os模块完成路径的拼接</span></span><br><span class="line">v3 = os.path.join(v2,<span class="string">&quot;CE1.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(v3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，本地路径可以写成这样的形式</span></span><br><span class="line">local =  os.path.join(os.path.dirname(os.path.abspath(__file__)),<span class="string">&quot;CE1.txt&quot;</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>利用os模块自动获取当前路径，以及使用datetime模块修改文件名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">path_dirs = <span class="string">&quot;files&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path_dirs):</span><br><span class="line">    os.makedirs(path_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># path = os.path.abspath(__file__)  # 获取当前py文件的绝对路径</span></span><br><span class="line"><span class="comment"># root_path = os.path.dirname(path)  # 获取path路径的上一级目录</span></span><br><span class="line"><span class="comment"># new_path = os.path.join(root_path, &quot;files&quot;)  # 实现路径的拼接,将root_path 与 files进行路径的拼接</span></span><br><span class="line">time_now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d-%H-%M-%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>, time_now + <span class="string">&quot;-CE1.cfg&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tran = paramiko.Transport((<span class="string">&quot;192.168.100.1&quot;</span>, <span class="number">22</span>))</span><br><span class="line">tran.connect(username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">sftp = paramiko.SFTPClient.from_transport(tran)  <span class="comment"># 从SSH会话的通道中建立sftp会话的通道</span></span><br><span class="line">sftp.get(<span class="string">&quot;/vrpcfg.cfg&quot;</span>, path)</span><br><span class="line"><span class="comment"># sftp.put(r&quot;E:\devops\pythonProject\CE1.cfg&quot;, &quot;/TEST.cfg&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="批量配置"><a href="#批量配置" class="headerlink" title="批量配置"></a>批量配置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&quot;N\n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    vty.send(<span class="string">&quot;system-view im \n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [&quot;192.168.100.&#123;&#125;&quot;.format(i) for i in range(1, 4)]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">num</span>):</span><br><span class="line">    data_list = [&#123;<span class="string">f&quot;CE<span class="subst">&#123;i&#125;</span>&quot;</span>: &#123;<span class="string">&quot;ip&quot;</span>: <span class="string">f&quot;192.168.100.<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">22</span>, <span class="string">&quot;username&quot;</span>: <span class="string">&quot;python&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;Huawei@123&quot;</span>&#125;&#125; <span class="keyword">for</span></span><br><span class="line">                 i <span class="keyword">in</span></span><br><span class="line">                 <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">        res = ssh_config(i[<span class="string">f&quot;CE<span class="subst">&#123;num&#125;</span>&quot;</span>][<span class="string">&quot;ip&quot;</span>], <span class="number">22</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;Huawei@123&quot;</span>, <span class="string">&quot;sftp.txt&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run(num=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&quot;N\n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    vty.send(<span class="string">&quot;system-view im \n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">ip, port, username, password, sysname</span>):</span><br><span class="line">    time_now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d-%H-%M-%S&quot;</span>)</span><br><span class="line">    path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>, time_now + <span class="string">f&quot;-<span class="subst">&#123;sysname&#125;</span>.cfg&quot;</span>)</span><br><span class="line">    tran = paramiko.Transport((ip, port))</span><br><span class="line">    tran.connect(username=username, password=password)</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(tran)</span><br><span class="line">    sftp.get(<span class="string">&quot;/vrpcfg.cfg&quot;</span>, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [&quot;192.168.100.&#123;&#125;&quot;.format(i) for i in range(1, 4)]</span></span><br><span class="line"><span class="comment"># def run(num):</span></span><br><span class="line"><span class="comment">#     data_list = [&#123;f&quot;CE&#123;i&#125;&quot;: &#123;&quot;ip&quot;: f&quot;192.168.100.&#123;i&#125;&quot;, &quot;port&quot;: 22, &quot;username&quot;: &quot;python&quot;, &quot;password&quot;: &quot;Huawei@123&quot;&#125;&#125; for</span></span><br><span class="line"><span class="comment">#                  i in</span></span><br><span class="line"><span class="comment">#                  range(1, 4)]</span></span><br><span class="line"><span class="comment">#     for i in data_list:</span></span><br><span class="line"><span class="comment">#         res = ssh_config(i[f&quot;CE&#123;num&#125;&quot;][&quot;ip&quot;], 22, &quot;python&quot;, &quot;Huawei@123&quot;, &quot;sftp.txt&quot;)</span></span><br><span class="line"><span class="comment">#         print(res)</span></span><br><span class="line"><span class="comment">#         num += 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_list = [&#123;<span class="string">&quot;ip&quot;</span>: <span class="string">f&quot;192.168.100.<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">&quot;sysname&quot;</span>: <span class="string">f&quot;CE<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">&quot;username&quot;</span>: <span class="string">&quot;python&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;Huawei@123&quot;</span>&#125; <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">             <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">    download(ip=i[<span class="string">&quot;ip&quot;</span>], port=<span class="number">22</span>, sysname=i[<span class="string">&quot;sysname&quot;</span>], username=i[<span class="string">&quot;username&quot;</span>], password=i[<span class="string">&quot;password&quot;</span>])</span><br></pre></td></tr></table></figure>



<h1 id="paramiko进阶"><a href="#paramiko进阶" class="headerlink" title="paramiko进阶"></a>paramiko进阶</h1><ul>
<li>第一期</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 在使用paramiko进行ssh登录时，可能会存在网络或者设备故障的问题</span></span><br><span class="line"><span class="comment"># 2. 如何判断设备登录成功</span></span><br><span class="line"><span class="comment"># 3. 如何保证回显完毕</span></span><br><span class="line"><span class="comment"># 4. 如何判断进入了系统视图</span></span><br><span class="line"><span class="comment"># 5. 如何判断命令执行成功</span></span><br><span class="line"><span class="comment"># 6. 命令执行成功之后，如何判断正确的返回了用户视图</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip</span>):</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.ip&#125;</span>链接失败&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetMarkError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GetMarkError&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSH</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.session = <span class="literal">None</span></span><br><span class="line">        self.vty = <span class="literal">None</span></span><br><span class="line">        self.login = <span class="literal">False</span></span><br><span class="line">        self.config = <span class="literal">False</span></span><br><span class="line">        self.old_mark = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        ssh_session = paramiko.SSHClient()</span><br><span class="line">        ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh_session.connect(hostname=self.ip, port=self.port, username=self.username, password=self.password)</span><br><span class="line">        self.session = ssh_session</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_vty</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.vty = self.session.invoke_shell()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mark</span>(<span class="params">self, output: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        pat = re.<span class="built_in">compile</span>(<span class="string">&quot;&lt;.+?&gt;&quot;</span>)  <span class="comment"># 创建一个正则表达式的对象</span></span><br><span class="line">        res = pat.findall(output)</span><br><span class="line">        <span class="keyword">if</span> res.__len__() != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> GetMarkError</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mark = self.old_mark = res[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_device</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.transport()</span><br><span class="line">            self.open_vty()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">raise</span> LoginError(self.ip)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        output = self.vty.recv(<span class="number">65535</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        self.get_mark(output)</span><br><span class="line">        self.login = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_result</span>(<span class="params">self, nbytes, interval=<span class="number">1</span></span>):</span><br><span class="line">        pat = re.<span class="built_in">compile</span>(self.mark)</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res = self.vty.recv(nbytes).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            ret += res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pat.search(res):</span><br><span class="line">                self.vty.send(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                time.sleep(interval)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.vty.send(command + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        res = self.recv_result(<span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_mode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.mark = <span class="string">&quot;\[.+?\]&quot;</span></span><br><span class="line">        self.test_command(<span class="string">&quot;system-view&quot;</span>)</span><br><span class="line">        self.config = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">self</span>):</span><br><span class="line">        self.mark = self.old_mark</span><br><span class="line">        <span class="keyword">return</span> self.test_command(<span class="string">&quot;return&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params">self, command: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config:</span><br><span class="line">            self.config_mode()</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> command:</span><br><span class="line">            res = self.test_command(i)</span><br><span class="line">            ret += res</span><br><span class="line">        ret += self.test_command(<span class="string">&quot;commit&quot;</span>)</span><br><span class="line">        ret += self.exit()</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ssh_client = SSH(ip=<span class="string">&quot;192.168.100.1&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Admin@123&quot;</span>)</span><br><span class="line">    res = ssh_client.send_command([<span class="string">&quot;interface GE1/0/0&quot;</span>, <span class="string">&quot;des ytedu&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<ul>
<li>第二期</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 在使用paramiko进行ssh登录时，可能会存在网络或者设备故障的问题</span></span><br><span class="line"><span class="comment"># 2. 如何判断设备登录成功</span></span><br><span class="line"><span class="comment"># 3. 如何保证回显完毕</span></span><br><span class="line"><span class="comment"># 4. 如何判断进入了系统视图</span></span><br><span class="line"><span class="comment"># 5. 如何判断命令执行成功</span></span><br><span class="line"><span class="comment"># 6. 命令执行成功之后，如何判断正确的返回了用户视图</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginError</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.ip&#125;</span> Login Error&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetMarkError</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.ip&#125;</span> GetMarkError&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSH</span>:</span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.ssh_session = <span class="literal">None</span></span><br><span class="line">        self.vty = <span class="literal">None</span></span><br><span class="line">        self.login = <span class="literal">False</span></span><br><span class="line">        self.config = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 创建SSH会话，并设置SSH会话的标识符</span></span><br><span class="line">        ssh_session = paramiko.SSHClient()</span><br><span class="line">        ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh_session.connect(hostname=self.ip, port=self.port, username=self.username,</span><br><span class="line">                            password=self.password)</span><br><span class="line">        self.ssh_session = ssh_session</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_vty</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 基于SSH会话建立命令行交互的会话，并设置标识符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.ssh_session:</span><br><span class="line">            self.transport()</span><br><span class="line">        self.vty = self.ssh_session.invoke_shell()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mark</span>(<span class="params">self, arg: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="comment"># 创建正则对象，匹配&lt;设备名称&gt;，如果匹配到说明登录成功，没有匹配到说明登陆失败，抛出异常</span></span><br><span class="line">        <span class="comment"># 设置mark标识符，此时代表是设备名称</span></span><br><span class="line">        pat = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;.+?&gt;&#x27;</span>)</span><br><span class="line">        res = pat.findall(arg)</span><br><span class="line">        <span class="keyword">if</span> res.__len__() == <span class="number">1</span>:</span><br><span class="line">            self.mark = self.old_mark = res[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># print(self.mark)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> GetMarkError(self.ip)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_device</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 创建设备登录的方法，并判断登录是否成功</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.transport()</span><br><span class="line">            self.open_vty()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">raise</span> LoginError(self.ip)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        content = self.vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="comment"># 将回显信息传入get_mark函数进行判断登录是否成功</span></span><br><span class="line">        self.get_mark(content)</span><br><span class="line">        self.login = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_result</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 创建正则对象，匹配&lt;设备名称&gt;，如果匹配到说明回显完整，没有匹配到说明回显不完整，继续敲空格</span></span><br><span class="line">        <span class="comment"># 将完整的回显返回出来</span></span><br><span class="line">        pat = re.<span class="built_in">compile</span>(self.mark)</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            content = self.vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(content)</span><br><span class="line">            ret += content</span><br><span class="line">            <span class="keyword">if</span> pat.search(content):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.vty.send(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 创建一个执行命令的方法，并调用recv_result()判断回显是否完整，并接收返回出的完整回显</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.vty.send(command + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        res = self.recv_result()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_mode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个进入系统视图的方法，并修改mark标识符匹配[~设备名]，如果匹配到说明成功进入系统视图</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.mark = <span class="string">&quot;\[.+?\]&quot;</span></span><br><span class="line">        self.send_command(<span class="string">&quot;system-view&quot;</span>)</span><br><span class="line">        self.config = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个返回用户视图的方法，修改mark标识符为&lt;设备名称&gt;，如果能匹配到则表明回到了用户视图</span></span><br><span class="line">        self.mark = self.old_mark</span><br><span class="line">        <span class="keyword">return</span> self.send_command(<span class="string">&quot;return&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_command</span>(<span class="params">self, command: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 创建一个执行命令的方法，执行完每一条命令都将结果拼接在ret变量中，最终返回完整的回显</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config:</span><br><span class="line">            self.config_mode()</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> command:</span><br><span class="line">            ret += self.send_command(i)</span><br><span class="line">        ret += self.send_command(<span class="string">&quot;commit&quot;</span>)</span><br><span class="line">        ret += self.exit()</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = SSH(ip=<span class="string">&quot;192.168.100.1&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Admin@123&quot;</span>)</span><br><span class="line">    res = a.config_command([<span class="string">&quot;interface G1/0/0&quot;</span>, <span class="string">&quot;des ytedu&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>



<h1 id="pysnmp"><a href="#pysnmp" class="headerlink" title="pysnmp"></a>pysnmp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = getCmd(SnmpEngine(),</span><br><span class="line">           UsmUserData(userName=<span class="string">&quot;admin&quot;</span>, authKey=<span class="string">&quot;Huawei@123&quot;</span>, privKey=<span class="string">&quot;Huawei@123&quot;</span>,</span><br><span class="line">                       authProtocol=usmHMACSHAAuthProtocol, privProtocol=usmAesCfb128Protocol),</span><br><span class="line">           UdpTransportTarget((<span class="string">&quot;192.168.100.1&quot;</span>, <span class="number">161</span>)),</span><br><span class="line">           ContextData(),</span><br><span class="line">           ObjectType(ObjectIdentity(<span class="string">&quot;1.3.6.1.2.1.1.5.0&quot;</span>)))</span><br><span class="line">errorIndication, errorStatus, errorIndex, varBinds =<span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> varBinds:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i).split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>].strip())</span><br></pre></td></tr></table></figure>

<ul>
<li>通过pysnmp获取设备名称，然后进行配置文件的下载</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">name</span>):</span><br><span class="line">    tran = paramiko.Transport((<span class="string">&#x27;192.168.100.1&#x27;</span>, <span class="number">22</span>))</span><br><span class="line">    tran.connect(username=<span class="string">&quot;python&quot;</span>,password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(tran)</span><br><span class="line">    <span class="comment"># get方法，将远程的文件下载到本地：remotepath localpath</span></span><br><span class="line">    now = datetime.now().strftime(<span class="string">&quot;%Y_%m_%d_%H_%M_%S&quot;</span>)+<span class="string">f&quot;_<span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">    remote = <span class="string">&quot;/vrpcfg.cfg&quot;</span></span><br><span class="line"></span><br><span class="line">    local = os.path.join(os.path.dirname(os.path.abspath(__file__)),now)</span><br><span class="line">    remote_put = <span class="string">&quot;CE1.cfg&quot;</span></span><br><span class="line">    <span class="comment"># sftp.put(local,remote_put)</span></span><br><span class="line">    sftp.get(remote,local)</span><br><span class="line">    sftp.close()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">snmp</span>():</span><br><span class="line">    get = getCmd(SnmpEngine(),</span><br><span class="line">                 UsmUserData(userName=<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                             authKey=<span class="string">&quot;Huawei@123&quot;</span>,</span><br><span class="line">                             privKey=<span class="string">&quot;Huawei@123&quot;</span>,</span><br><span class="line">                             authProtocol=usmHMACSHAAuthProtocol,</span><br><span class="line">                             privProtocol=usmAesCfb128Protocol),</span><br><span class="line">                 UdpTransportTarget((<span class="string">&quot;192.168.100.1&quot;</span>,<span class="number">161</span>)),</span><br><span class="line">                                    ContextData(),</span><br><span class="line">                             ObjectType(ObjectIdentity(<span class="string">&#x27;1.3.6.1.2.1.1.5.0&#x27;</span>)))</span><br><span class="line">    a, b, c, d = <span class="built_in">next</span>(get)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">        res = <span class="built_in">str</span>(i).split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arg = snmp()</span><br><span class="line">    download(arg)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="ssh大通道建立连接"><a href="#ssh大通道建立连接" class="headerlink" title="ssh大通道建立连接"></a>ssh大通道建立连接</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line">ssh_client = paramiko.SSHClient()</span><br><span class="line">ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 默认使用账号密码进行用户认证时，需要先获取服务器的公钥，服务器将公钥发送给客户端时，客户端默认不会立即接收该公钥</span></span><br><span class="line"><span class="comment"># 而set_missing_host_key_policy(paramiko.AutoAddPolicy())的作用就是让我们可以不输入yes or no的情况下自动把公钥保存在本地</span></span><br><span class="line">ssh_client.connect(hostname=<span class="string">&quot;192.168.56.100&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line"><span class="comment"># 传输命令 打开命令行交互小通道</span></span><br><span class="line">vty = ssh_client.invoke_shell()</span><br><span class="line"><span class="comment"># 拉取回显信息</span></span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Warning: The initial password poses security risks.</span></span><br><span class="line"><span class="string">The password needs to be changed. Change now? [Y/N]:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line">ssh_client = paramiko.SSHClient()</span><br><span class="line">ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 默认使用账号密码进行用户认证时，需要先获取服务器的公钥，服务器将公钥发送给客户端时，客户端默认不会立即接收该公钥</span></span><br><span class="line"><span class="comment"># 而set_missing_host_key_policy(paramiko.AutoAddPolicy())的作用就是让我们可以不输入yes or no的情况下自动把公钥保存在本地</span></span><br><span class="line">ssh_client.connect(hostname=<span class="string">&quot;192.168.56.100&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line"><span class="comment"># 传输命令 打开命令行交互小通道</span></span><br><span class="line">vty = ssh_client.invoke_shell()</span><br><span class="line"><span class="comment"># 拉取回显信息</span></span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&#x27;N\n&#x27;</span>)  <span class="comment"># 内部自动转码</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&#x27;screen-length 0 temporary\n&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">vty.send(<span class="string">&#x27;dis cu\n&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>







<h2 id="批量配置sftp"><a href="#批量配置sftp" class="headerlink" title="批量配置sftp"></a>批量配置sftp</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&#x27;N\n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    vty.send(<span class="string">&#x27;system-view im \n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [&#x27;192.168.56.&#123;&#125;&#x27;.format(i) for i in range(100, 130, 10)]</span></span><br><span class="line"><span class="comment"># print(data_list)</span></span><br><span class="line"><span class="comment"># data_list = [&#123;&#x27;ip&#x27;: f&#x27;192.168.56.&#123;i&#125;&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125; for i in</span></span><br><span class="line"><span class="comment">#              range(100, 130, 10)]</span></span><br><span class="line"><span class="comment"># print(data_list)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#x27;192.168.56.100&#x27;, &#x27;192.168.56.110&#x27;, &#x27;192.168.56.120&#x27;]</span></span><br><span class="line"><span class="string">[&#123;&#x27;ip&#x27;: &#x27;192.168.56.100&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125;, </span></span><br><span class="line"><span class="string">&#123;&#x27;ip&#x27;: &#x27;192.168.56.110&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125;, </span></span><br><span class="line"><span class="string">&#123;&#x27;ip&#x27;: &#x27;192.168.56.120&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data_list = [&#123;<span class="string">f&#x27;CE<span class="subst">&#123;i&#125;</span>&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">f&#x27;192.168.56.<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125; <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">             <span class="built_in">range</span>(<span class="number">101</span>, <span class="number">104</span>)]</span><br><span class="line"><span class="built_in">print</span>(data_list)</span><br><span class="line"></span><br><span class="line">num = <span class="number">101</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">    res = ssh_config(i[<span class="string">f&#x27;CE<span class="subst">&#123;num&#125;</span>&#x27;</span>][<span class="string">&#x27;ip&#x27;</span>], <span class="number">22</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;Huawei@123&#x27;</span>, <span class="string">&#x27;sftp.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"><span class="comment"># res = ssh_config(&#x27;192.168.56.101&#x27;, 22, &#x27;python&#x27;, &#x27;Huawei@123&#x27;, &#x27;sftp.txt&#x27;)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&#x27;CE101&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;192.168.56.101&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;CE102&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;192.168.56.102&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;CE103&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;192.168.56.103&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125;]</span><br><span class="line"></span><br><span class="line">Warning: The initial password poses security risks.</span><br><span class="line">The password needs to be changed. Change now? [Y/N]:N</span><br><span class="line"></span><br><span class="line">Info: The <span class="built_in">max</span> number of VTY users <span class="keyword">is</span> <span class="number">5</span>, the number of current VTY users online <span class="keyword">is</span> <span class="number">1</span>, <span class="keyword">and</span> total number of terminal users online <span class="keyword">is</span> <span class="number">2.</span></span><br><span class="line">      The current login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">50.</span></span><br><span class="line">      The last login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">11</span>:07:07 <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span> through SSH.</span><br><span class="line">&lt;CE1&gt;system-view im </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[CE1]sftp server enable</span><br><span class="line">Info: The SFTP server <span class="keyword">is</span> already started.</span><br><span class="line">[CE1]ssh user python service-<span class="built_in">type</span> stelnet sftp</span><br><span class="line">[CE1]ssh user python sftp-directory cfcard:</span><br><span class="line">[CE1]ssh authorization-<span class="built_in">type</span> default root</span><br><span class="line"></span><br><span class="line">Warning: The initial password poses security risks.</span><br><span class="line">The password needs to be changed. Change now? [Y/N]:N</span><br><span class="line"></span><br><span class="line">Info: The <span class="built_in">max</span> number of VTY users <span class="keyword">is</span> <span class="number">5</span>, the number of current VTY users online <span class="keyword">is</span> <span class="number">1</span>, <span class="keyword">and</span> total number of terminal users online <span class="keyword">is</span> <span class="number">2.</span></span><br><span class="line">      The current login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">57.</span></span><br><span class="line">      First login successfully.</span><br><span class="line">&lt;CE2&gt;system-view im </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[CE2]sftp server enable</span><br><span class="line">Info: Succeeded <span class="keyword">in</span> starting the SFTP server.</span><br><span class="line">[CE2]ssh user python service-<span class="built_in">type</span> stelnet sftp</span><br><span class="line">[CE2]ssh user python sftp-directory cfcard:</span><br><span class="line">[CE2]ssh authorization-<span class="built_in">type</span> default root</span><br><span class="line"></span><br><span class="line">Warning: The initial password poses security risks.</span><br><span class="line">The password needs to be changed. Change now? [Y/N]:N</span><br><span class="line"></span><br><span class="line">Info: The <span class="built_in">max</span> number of VTY users <span class="keyword">is</span> <span class="number">5</span>, the number of current VTY users online <span class="keyword">is</span> <span class="number">1</span>, <span class="keyword">and</span> total number of terminal users online <span class="keyword">is</span> <span class="number">2.</span></span><br><span class="line">      The current login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">15</span>:<span class="number">57</span>:<span class="number">04.</span></span><br><span class="line">      First login successfully.</span><br><span class="line">&lt;CE3&gt;system-view im </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[CE3]sftp server enable</span><br><span class="line">Info: Succeeded <span class="keyword">in</span> starting the SFTP server.</span><br><span class="line">[CE3]ssh user python service-<span class="built_in">type</span> stelnet sftp</span><br><span class="line">[CE3]ssh user python sftp-directory cfcard:</span><br><span class="line">[CE3]ssh authorization-<span class="built_in">type</span> default root</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量下载ensp配置</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&#x27;N\n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    vty.send(<span class="string">&#x27;system-view im \n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">ip, port, sysname, username, password</span>):</span><br><span class="line">    today = datetime.now()</span><br><span class="line">    time_now = today.strftime(<span class="string">&quot;%Y-%m-%d %H-%M-%S&quot;</span>)</span><br><span class="line">    path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>, time_now + <span class="string">f&quot;-<span class="subst">&#123;sysname&#125;</span>.cfg&quot;</span>)</span><br><span class="line">    tran = paramiko.Transport((ip, port))</span><br><span class="line">    tran.connect(username=username, password=password)</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(tran)</span><br><span class="line">    sftp.get(<span class="string">&#x27;/vrpcfg.cfg&#x27;</span>, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_list = [&#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">f&#x27;192.168.56.<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="string">&#x27;sysname&#x27;</span>: <span class="string">f&#x27;CE<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>, <span class="number">104</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">    download(ip=i[<span class="string">&quot;ip&quot;</span>], port=<span class="number">22</span>, sysname=i[<span class="string">&quot;sysname&quot;</span>], username=i[<span class="string">&quot;username&quot;</span>], password=i[<span class="string">&quot;password&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 在使用paramiko进行ssh登录时，可能会存在网络或者设备故障的问题</span></span><br><span class="line"><span class="comment"># 2. 如何判断设备登录成功</span></span><br><span class="line"><span class="comment"># 3. 如何保证回显完毕</span></span><br><span class="line"><span class="comment"># 4. 如何判断进入了系统视图</span></span><br><span class="line"><span class="comment"># 5. 如何判断命令执行成功</span></span><br><span class="line"><span class="comment"># 6. 命令执行成功之后，如何判断正确的返回了用户视图</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip</span>):</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.ip&#125;</span> 连接失败&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetMarkError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get-mark-error&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSH</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.session = <span class="literal">None</span></span><br><span class="line">        self.vty = <span class="literal">None</span></span><br><span class="line">        self.login = <span class="literal">False</span></span><br><span class="line">        self.config = <span class="literal">False</span></span><br><span class="line">        self.old_mark = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        ssh_session = paramiko.SSHClient()</span><br><span class="line">        ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh_session.connect(hostname=self.ip, port=self.port, username=self.username, password=self.password)</span><br><span class="line">        self.session = ssh_session</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_vty</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.vty = self.session.invoke_shell()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断抓取信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mark</span>(<span class="params">self, output: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 创建正则表达式对象</span></span><br><span class="line">        pat = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;.+?&gt;&#x27;</span>)</span><br><span class="line">        res = pat.findall(output)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> GetMarkError</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mark = self.old_mark = res[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span>(self.mark)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_device</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.transport()</span><br><span class="line">            self.open_vty()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;success login&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">raise</span> LoginError(self.ip)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        output = self.vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.get_mark(output)</span><br><span class="line">        self.login = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_result</span>(<span class="params">self, nbytes, interval=<span class="number">0.5</span></span>):</span><br><span class="line">        pat = re.<span class="built_in">compile</span>(self.mark)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res = self.vty.recv(nbytes).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            <span class="comment"># res += res</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pat.search(res):</span><br><span class="line">                time.sleep(interval)</span><br><span class="line">                self.vty.send(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        <span class="comment"># 新的表达式匹配方式</span></span><br><span class="line">        <span class="comment"># self.mark = &#x27;\[.+?\]&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.vty.send(command + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        res = self.recv_result(<span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># time.sleep(1)</span></span><br><span class="line">        <span class="comment"># return self.vty.recv(65535).decode(&#x27;utf-8&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_mode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.mark = <span class="string">&#x27;\[.+?\]&#x27;</span></span><br><span class="line">        self.test_command(<span class="string">&#x27;system-view&#x27;</span>)</span><br><span class="line">        self.config = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">self</span>):</span><br><span class="line">        self.mark = self.old_mark</span><br><span class="line">        <span class="keyword">return</span> self.test_command(<span class="string">&#x27;return&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params">self, command: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config:</span><br><span class="line">            self.config_mode()</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> command:</span><br><span class="line">            res = self.test_command(i)</span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            ret += res</span><br><span class="line">        ret += self.test_command(<span class="string">&#x27;commit&#x27;</span>)</span><br><span class="line">        ret += self.exit()</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ssh_client = SSH(ip=<span class="string">&#x27;192.168.56.102&#x27;</span>, port=<span class="number">22</span>, username=<span class="string">&#x27;python&#x27;</span>, password=<span class="string">&#x27;Cloud12#$&#x27;</span>)</span><br><span class="line">    <span class="comment"># res = ssh_client.login_device()</span></span><br><span class="line">    <span class="comment"># res = ssh_client.send_command(&#x27;dis cu&#x27;)</span></span><br><span class="line">    res = ssh_client.send_command([<span class="string">&quot;interface GE1/0/0&quot;</span>, <span class="string">&#x27;des cloud&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
      </tags>
  </entry>
</search>
