<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NETCONF与YANG编程</title>
    <url>/2023/10/18/NETCONF%E4%B8%8EYANG%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>介绍：</p>
<p>NETCONF协议是一种网络设备管理协议，类似SNMP，提供一套新增、修 改、删除网络设备配置，查询配置、状态和统计信息的框架机制。</p>
<p>YANG是数据模型定义语言，可以用来描述基于NETCONF协议通信的客户 端和服务器之间的交互模型，类似SNMP使用MIB文件作为数据模型。</p>
<span id="more"></span>

<h1 id="NETCONF与YANG编程"><a href="#NETCONF与YANG编程" class="headerlink" title="NETCONF与YANG编程"></a>NETCONF与YANG编程</h1><h1 id="实现自动化必要的趋势"><a href="#实现自动化必要的趋势" class="headerlink" title="实现自动化必要的趋势"></a>实现自动化必要的趋势</h1><h2 id="缩短部署时间"><a href="#缩短部署时间" class="headerlink" title="缩短部署时间"></a>缩短部署时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">自动化可以帮助减少部署时间。可编程性有助于快速验证新的功能、部署新的服务并且立即升级路由器。这要求网络设备具有一致和完整的应用编程接口(API)，最终目标是使网络运维工作中所有可以自动化的工作全部自动化。</span><br></pre></td></tr></table></figure>



<h2 id="CLI无法作为标准"><a href="#CLI无法作为标准" class="headerlink" title="CLI无法作为标准"></a>CLI无法作为标准</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">虽然CLI不是API，但不幸的是不得不将其视为一个API，因为必须长期依赖它。然而，使用CLI进行自动化既不可靠，也不具有成本效益。</span><br><span class="line">首先，许多与服务相关的配置更改会涉及一个以上的设备，配置更改变得越来越复杂</span><br><span class="line">其次，虽然CLI是人性化的，但却不适合自动化，原因如下：</span><br><span class="line"><span class="number">1.</span>CLI没有标准化。虽然网络设备配置CLI是相似的，但从语法和语义的角度来看，不同厂商或特定厂商的操作系统并不一致。</span><br><span class="line"><span class="number">2.</span>通过CLI配置设备时存在依赖性问题。某些情况下，配置VLAN之前必须输入用于配置接口的CLI命令。如果这些步骤未按正确的顺序执行，则配置失败，或者更糟糕的是，配置仅部分完成</span><br><span class="line"><span class="number">3.</span>CLI只提供有限的错误报告，还不能以易于使用的脚本格方式报告错误</span><br><span class="line"><span class="number">4.</span>CLI不产生任何结构化的输出。因此，从display命令中提取信息的唯一方法是通过“屏幕抓取”，或使用正则表达式模式匹配从输出中提取数据。最后，<span class="string">&quot;display命令&quot;</span>经常更改以显示更多功能、更多计数器等。问题是即使对display命令</span><br><span class="line">进行更小的更改（例如在输出中添加空格）也可能会破坏对于特定值的提取</span><br><span class="line"><span class="number">5.</span>必须清楚设备的特征，例如用telnet登录必须匹配到某段字符串，然而你在真正了解此型号的设备之前，是无法预知会出现怎样的显示信息的</span><br><span class="line"><span class="number">6.</span>依赖命令行限制了网络的发展，例如害怕升级设备会导致自动化脚本的中断，所以推迟或不去部署必要的安全补丁。而这种升级的恐惧也解释了以数据模型来作为驱动的自动化速度很缓慢</span><br></pre></td></tr></table></figure>



<h2 id="硬件与软件的解耦"><a href="#硬件与软件的解耦" class="headerlink" title="硬件与软件的解耦"></a>硬件与软件的解耦</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">行业越来越倾向于将软件和硬件进行分离，最终目标是将白盒组装成统一的硬件，以Linux为操作系统，并针对不同网络功能使用特定的应用程序---可能从一个供应商购买BGP功能，从另一个供应商购买OSPF协议，再从第三个供应商购买RADIUS和管理功能。这样做的优势显而易见：</span><br><span class="line"><span class="number">1.</span>全部使用Linux模糊了服务器和网络管理之间的界限，并降低了支持成本。不仅“路由器”和“交换机”都在Linux上运行，Linux环境还提供了许多工具和应用程序，包括管理操作</span><br><span class="line"><span class="number">2.</span>使用Linux意味着更广泛的共识：人们直接从学校开始接受更好的培训。在硬件商品化的情况下联网不再困难，因为厂商的CLI不是唯一的。换句话说，不同的设备厂商在CLI方面不再竞争。更多的不再需要专门懂某个厂商设备的人，而转向具有linux和脚本技能的人选。因此，高级网络工程师应该少关注厂商的具体内容，多关注更广泛的网络架构和技术基础。而对于厂商来说，除了关注认证以及部分基于CLI的知识，还应该更加关注独立于CLI之外的网络编程和操作方面的内容</span><br><span class="line"><span class="number">3.</span>在网络中使用相同的硬件，而不是特殊的专用硬件，可以降低网络的复杂性（缺点是硬件bug会影响到所有平台）</span><br><span class="line"><span class="number">4.</span>网络和服务工程师可以专注于面向业务的任务，而不仅仅是网络运营和维护。网络开始成为业务的推动者，而业务和网络之间的链接正是软件。随着自动化所节约的时间，工程师将成为推动网络创新以满足业务需求的关键推动力</span><br></pre></td></tr></table></figure>



<h2 id="数据模型驱动的管理"><a href="#数据模型驱动的管理" class="headerlink" title="数据模型驱动的管理"></a>数据模型驱动的管理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">良好的脚本需要基于良好的API</span><br><span class="line"><span class="number">1.</span>可编程API应该抽象化底层实现的复杂性。Devops工程师不需要知道不必要的详细信息，例如网元的特定配置顺序，或者在发生故障时需要采取的具体步骤。如果上述信息对人类来说不直观，那么配置引擎的命令排序就会更加复杂。配置的功能应该更像是填写高级检查清单（这些是你需要的设置；现在系统可以确定如何正确分组和排序）</span><br><span class="line"><span class="number">2.</span>API关键工作（无论是软件API还是网络API）是为数据提供规格。首先，它回答了数据是什么的问题----整数、字符串或其他类型的值？接下来，它指定了该数据的组织方式。在传统编程中这被称为数据结构，在网络可编程性和数据库的世界中更常见的术语是架构，也称为数据模型</span><br><span class="line"><span class="number">3.</span>访问数据的方法：API需要为如何读取和操作数据提供标准化的框架</span><br><span class="line"><span class="number">4.</span>将API应用于复杂的环境时，关键是供应商以基于标准的方式实施API。不同设备和供应商之间定义和访问数据应该有一种通用方法，运维人员不必为网络中的每个不同设备和功能学习单独的专有接口</span><br></pre></td></tr></table></figure>



<h1 id="案例1：使用netconf配置日志主机位"><a href="#案例1：使用netconf配置日志主机位" class="headerlink" title="案例1：使用netconf配置日志主机位"></a>案例1：使用netconf配置日志主机位</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ncclient.xml_ <span class="keyword">import</span> to_ele</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ncclient  模块  很多东西都补全不了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">netconf</span>():</span><br><span class="line">    <span class="keyword">return</span> manager.connect(host=<span class="string">&quot;192.168.100.1&quot;</span>,</span><br><span class="line">                           port=<span class="number">830</span>,</span><br><span class="line">                           username=<span class="string">&quot;netconf&quot;</span>,</span><br><span class="line">                           password=<span class="string">&quot;Huawei12#$&quot;</span>,</span><br><span class="line">                           look_for_keys=<span class="literal">False</span>,</span><br><span class="line">                           allow_agent=<span class="literal">False</span>,</span><br><span class="line">                           hostkey_verify=<span class="literal">False</span>,</span><br><span class="line">                           device_params=&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;huawei&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    CONFIG = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;edit-config&gt;</span></span><br><span class="line"><span class="string">    &lt;target&gt;</span></span><br><span class="line"><span class="string">      &lt;running/&gt;</span></span><br><span class="line"><span class="string">    &lt;/target&gt;</span></span><br><span class="line"><span class="string">    &lt;default-operation&gt;merge&lt;/default-operation&gt;</span></span><br><span class="line"><span class="string">    &lt;error-option&gt;rollback-on-error&lt;/error-option&gt;</span></span><br><span class="line"><span class="string">    &lt;config&gt;</span></span><br><span class="line"><span class="string">      &lt;syslog xmlns=&quot;http://www.huawei.com/netconf/vrp&quot; content-version=&quot;1.0&quot; format-version=&quot;1.0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;syslogServers&gt;</span></span><br><span class="line"><span class="string">          &lt;syslogServer operation=&quot;merge&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;ipType&gt;ipv4&lt;/ipType&gt;</span></span><br><span class="line"><span class="string">            &lt;serverIp&gt;10.1.60.2&lt;/serverIp&gt;</span></span><br><span class="line"><span class="string">            &lt;isDefaultVpn&gt;false&lt;/isDefaultVpn&gt;</span></span><br><span class="line"><span class="string">            &lt;vrfName&gt;_public_&lt;/vrfName&gt;</span></span><br><span class="line"><span class="string">            &lt;timestamp&gt;UTC&lt;/timestamp&gt;</span></span><br><span class="line"><span class="string">            &lt;transportMode&gt;tcp&lt;/transportMode&gt;</span></span><br><span class="line"><span class="string">          &lt;/syslogServer&gt;</span></span><br><span class="line"><span class="string">        &lt;/syslogServers&gt;</span></span><br><span class="line"><span class="string">      &lt;/syslog&gt;</span></span><br><span class="line"><span class="string">    &lt;/config&gt;</span></span><br><span class="line"><span class="string">  &lt;/edit-config&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        m = netconf()</span><br><span class="line">        <span class="comment"># 将字符串转换成XML文件对象</span></span><br><span class="line">        content = to_ele(CONFIG)</span><br><span class="line">        res = m.rpc(content)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&lt;ok/&gt;&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(res):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;execute successfully&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;execute fail&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<h2 id="使用Netconf查询日志主机位"><a href="#使用Netconf查询日志主机位" class="headerlink" title="使用Netconf查询日志主机位"></a>使用Netconf查询日志主机位</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> manager</span><br><span class="line"><span class="keyword">from</span> ncclient.xml_ <span class="keyword">import</span> to_ele</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ncclient  模块  很多东西都补全不了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">netconf</span>():</span><br><span class="line">    <span class="keyword">return</span> manager.connect(host=<span class="string">&quot;192.168.100.1&quot;</span>,</span><br><span class="line">                           port=<span class="number">830</span>,</span><br><span class="line">                           username=<span class="string">&quot;netconf&quot;</span>,</span><br><span class="line">                           password=<span class="string">&quot;Huawei12#$&quot;</span>,</span><br><span class="line">                           look_for_keys=<span class="literal">False</span>,</span><br><span class="line">                           allow_agent=<span class="literal">False</span>,</span><br><span class="line">                           hostkey_verify=<span class="literal">False</span>,</span><br><span class="line">                           device_params=&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;huawei&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    CONFIG = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  &lt;get&gt;</span></span><br><span class="line"><span class="string">    &lt;filter type=&quot;subtree&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;syslog xmlns=&quot;http://www.huawei.com/netconf/vrp&quot; content-version=&quot;1.0&quot; format-version=&quot;1.0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;syslogServers&gt;</span></span><br><span class="line"><span class="string">          &lt;syslogServer&gt;</span></span><br><span class="line"><span class="string">            &lt;ipType&gt;&lt;/ipType&gt;</span></span><br><span class="line"><span class="string">            &lt;serverIp&gt;&lt;/serverIp&gt;</span></span><br><span class="line"><span class="string">            &lt;isDefaultVpn&gt;&lt;/isDefaultVpn&gt;</span></span><br><span class="line"><span class="string">            &lt;vrfName&gt;&lt;/vrfName&gt;</span></span><br><span class="line"><span class="string">            &lt;timestamp&gt;&lt;/timestamp&gt;</span></span><br><span class="line"><span class="string">            &lt;transportMode&gt;&lt;/transportMode&gt;</span></span><br><span class="line"><span class="string">            &lt;sslPolicyName&gt;&lt;/sslPolicyName&gt;</span></span><br><span class="line"><span class="string">            &lt;isBriefFmt&gt;&lt;/isBriefFmt&gt;</span></span><br><span class="line"><span class="string">          &lt;/syslogServer&gt;</span></span><br><span class="line"><span class="string">        &lt;/syslogServers&gt;</span></span><br><span class="line"><span class="string">      &lt;/syslog&gt;</span></span><br><span class="line"><span class="string">    &lt;/filter&gt;</span></span><br><span class="line"><span class="string">  &lt;/get&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">    m = netconf()</span><br><span class="line">    <span class="comment"># 将字符串转换成XML文件对象</span></span><br><span class="line">    content = to_ele(CONFIG)</span><br><span class="line">    res = m.rpc(content)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    m.close()</span><br></pre></td></tr></table></figure>



<h2 id="netconf-配置-vlan"><a href="#netconf-配置-vlan" class="headerlink" title="#netconf 配置 vlan"></a>#netconf 配置 vlan</h2><p>以下预先在CE配置ssh</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> manager</span><br><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> operations</span><br><span class="line"></span><br><span class="line">CREATE_VLAN = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;config&gt;</span></span><br><span class="line"><span class="string">      &lt;vlan xmlns=&quot;http://www.huawei.com/netconf/vrp&quot; content-version=&quot;1.0&quot; format-version=&quot;1.0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;vlans&gt;</span></span><br><span class="line"><span class="string">          &lt;vlan operation=&quot;merge&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;vlanId&gt;10&lt;/vlanId&gt;</span></span><br><span class="line"><span class="string">            &lt;vlanName&gt;VLAN10&lt;/vlanName&gt;</span></span><br><span class="line"><span class="string">            &lt;vlanType&gt;common&lt;/vlanType&gt;</span></span><br><span class="line"><span class="string">          &lt;/vlan&gt;</span></span><br><span class="line"><span class="string">        &lt;/vlans&gt;</span></span><br><span class="line"><span class="string">      &lt;/vlan&gt;</span></span><br><span class="line"><span class="string">    &lt;/config&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">netconf_manager</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    <span class="keyword">return</span> manager.connect(</span><br><span class="line">        host=ip,</span><br><span class="line">        port=port,</span><br><span class="line">        username=username,</span><br><span class="line">        password=password,</span><br><span class="line">        look_for_keys=<span class="literal">False</span>,</span><br><span class="line">        allow_agent=<span class="literal">False</span>,</span><br><span class="line">        hostkey_verify=<span class="literal">False</span>,</span><br><span class="line">        device_params=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;huawei&#x27;</span>&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_response</span>(<span class="params">rpc_obj, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;RPCReplay for <span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;rpc_obj.xml&#125;</span>&#x27;</span>)</span><br><span class="line">    xml_str = rpc_obj.xml</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&lt;ok/&gt;&#x27;</span> <span class="keyword">in</span> xml_str:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> successfully&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Cannot successfully excute: <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_edit</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    <span class="keyword">with</span> netconf_manager(ip, port, username, password) <span class="keyword">as</span> m:</span><br><span class="line">        rpc_obj = m.edit_config(target=<span class="string">&#x27;running&#x27;</span>, config=CREATE_VLAN)</span><br><span class="line">        check_response(rpc_obj, CREATE_VLAN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_edit(<span class="string">&#x27;192.168.56.200&#x27;</span>, <span class="number">830</span>, <span class="string">&#x27;netconf&#x27;</span>, <span class="string">&#x27;Huawei12#$&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">-----------------------------------</span><br><span class="line">F:\Python\Python310\python.exe C:\Users\admin\Desktop\MyStudySpace\project\devops\ncclient_t.py </span><br><span class="line">RPCReplay <span class="keyword">for</span> </span><br><span class="line">&lt;config&gt;</span><br><span class="line">      &lt;vlan xmlns=<span class="string">&quot;http://www.huawei.com/netconf/vrp&quot;</span> content-version=<span class="string">&quot;1.0&quot;</span> <span class="built_in">format</span>-version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">        &lt;vlans&gt;</span><br><span class="line">          &lt;vlan operation=<span class="string">&quot;merge&quot;</span>&gt;</span><br><span class="line">            &lt;vlanId&gt;<span class="number">10</span>&lt;/vlanId&gt;</span><br><span class="line">            &lt;vlanName&gt;VLAN10&lt;/vlanName&gt;</span><br><span class="line">            &lt;vlanType&gt;common&lt;/vlanType&gt;</span><br><span class="line">          &lt;/vlan&gt;</span><br><span class="line">        &lt;/vlans&gt;</span><br><span class="line">      &lt;/vlan&gt;</span><br><span class="line">    &lt;/config&gt;</span><br><span class="line"> <span class="keyword">is</span> &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;rpc-reply message-<span class="built_in">id</span>=<span class="string">&quot;urn:uuid:fd908a16-c192-4eab-98d2-9caa6d2bc108&quot;</span> xmlns=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span> flow-<span class="built_in">id</span>=<span class="string">&quot;37&quot;</span>&gt;</span><br><span class="line">  &lt;ok/&gt;</span><br><span class="line">&lt;/rpc-reply&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;config&gt;</span><br><span class="line">      &lt;vlan xmlns=<span class="string">&quot;http://www.huawei.com/netconf/vrp&quot;</span> content-version=<span class="string">&quot;1.0&quot;</span> <span class="built_in">format</span>-version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">        &lt;vlans&gt;</span><br><span class="line">          &lt;vlan operation=<span class="string">&quot;merge&quot;</span>&gt;</span><br><span class="line">            &lt;vlanId&gt;<span class="number">10</span>&lt;/vlanId&gt;</span><br><span class="line">            &lt;vlanName&gt;VLAN10&lt;/vlanName&gt;</span><br><span class="line">            &lt;vlanType&gt;common&lt;/vlanType&gt;</span><br><span class="line">          &lt;/vlan&gt;</span><br><span class="line">        &lt;/vlans&gt;</span><br><span class="line">      &lt;/vlan&gt;</span><br><span class="line">    &lt;/config&gt;</span><br><span class="line"> successfully</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>NETCONF</tag>
        <tag>YANG</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH原理与实践</title>
    <url>/2023/10/18/SSH%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>介绍：SH（Secure Shell，安全外壳）是一种网络安全协议，通过加密和认证机制实现安全的访问和文件传输等业务。传统远程登录或文件传输方式，例如Telnet、FTP，使用明文传输数据，存在很多的安全隐患。随着人们对网络安全的重视，这些方式已经慢慢不被接受。SSH协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的登录和其他安全网络服务。作为Telnet和其他不安全远程shell协议的安全替代方案，目前SSH协议已经被全世界广泛使用，大多数设备都支持SSH功能。</p>
<span id="more"></span>

<h1 id="SSH原理与实践"><a href="#SSH原理与实践" class="headerlink" title="SSH原理与实践"></a>SSH原理与实践</h1><h2 id="SSH简介"><a href="#SSH简介" class="headerlink" title="SSH简介"></a>SSH简介</h2><ul>
<li>SSH（Secure Shell，安全外壳协议）是一种用于在不安全网络上进行安全远程登录和实现其他安全网络服务的协议。</li>
<li>SSH协议由三个组件构成：SSH传输层协议，SSH用户认证协议，SSH连接协议。<ul>
<li>SSH传输层协议：版本协商、算法协商、密钥交换</li>
<li>SSH用户认证协议：用户认证（口令、密钥）</li>
<li>SSH连接协议：建立会话连接</li>
</ul>
</li>
</ul>
<h1 id="密码学补充"><a href="#密码学补充" class="headerlink" title="密码学补充"></a>密码学补充</h1><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><ul>
<li>对称加密 ：加密和解密使用的是同一把密钥<ul>
<li>优点：加密速度快</li>
<li>缺点：不安全，密钥在传输过程当中存在安全风险</li>
</ul>
</li>
</ul>
<p><img src="image-20220617145822207.png" alt="image-20220617145822207"></p>
<ul>
<li><p>非对称加密：每一方拥有两把钥匙，一把叫做公钥，一把叫私钥：公钥加密，私钥解密；私钥加密，公钥解密</p>
<ul>
<li><p>优点：安全，私钥是保存在本地的，也就意味着，即便密文被获取到，也无法进行解密</p>
</li>
<li><p>缺点：加密速度慢。虽然攻击者无法通过密文得到明文信息，但是可以篡改信息</p>
</li>
</ul>
</li>
</ul>
<p><img src="image-20220617145855011.png" alt="image-20220617145855011"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如何获取对方的公钥：</span><br><span class="line"><span class="number">1.</span>发起请求来获取</span><br><span class="line"><span class="number">2.</span>可以将自己的公钥放在一台公共的服务器上</span><br></pre></td></tr></table></figure>



<h2 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h2><ul>
<li>核心概念：对于明文还是采用对称加密的方式，而对于对称加密的密钥，采用非对称加密的方式</li>
<li>优点：在保证安全性的前提下，又提升了加密的速度</li>
<li>缺点：虽然攻击者无法通过密文得到明文信息，但是可以篡改信息</li>
</ul>
<p><img src="image-20220617145937979.png" alt="image-20220617145937979"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">此时假设甲向乙发送信息：</span><br><span class="line"><span class="number">1.</span>甲采用对称密钥对明文信息进行加密</span><br><span class="line"><span class="number">2.</span>甲使用乙的公钥对对称密钥进行加密，得到就是数字信封</span><br><span class="line"><span class="number">3.</span>甲将密文以及数字信封发送给乙</span><br><span class="line"><span class="number">4.</span>乙收到密文以及数字信封之后，先用自己的私钥对数字信封进行解密，得到对称密钥</span><br><span class="line"><span class="number">5.</span>乙使用解密得到的对称密钥再对密文信息进行解密，得到最原始的明文信息</span><br></pre></td></tr></table></figure>





<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p><img src="image-20220617150000236.png" alt="image-20220617150000236"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">假设甲要向乙发送信息</span><br><span class="line"><span class="number">1.</span>甲采用对称密钥对明文信息进行加密</span><br><span class="line"><span class="number">2.</span>甲使用乙的公钥对对称密钥进行加密，得到就是数字信封</span><br><span class="line"><span class="number">3.</span>甲将最原始的明文信息通过<span class="built_in">hash</span>计算得到一段<span class="built_in">hash</span>-<span class="number">1</span>值，并将该<span class="built_in">hash</span>值使用甲的私钥进行加密，得到一个数字签名</span><br><span class="line"><span class="number">4.</span>甲将密文、数字信封以及数字签名发送给乙</span><br><span class="line"><span class="number">5.</span>乙通过自己的私钥对数字信封进行解密，得到对称密钥</span><br><span class="line"><span class="number">6.</span>乙使用对称密钥对密文信息进行解密，得到明文信息</span><br><span class="line"><span class="number">7.</span>乙使用该明文信息通过<span class="built_in">hash</span>计算得到一段<span class="built_in">hash</span>-<span class="number">2</span>值</span><br><span class="line"><span class="number">8.</span>乙使用甲的公钥对数字签名进行解密，得到<span class="built_in">hash</span>-<span class="number">1</span>值</span><br><span class="line"><span class="number">9.</span>乙将<span class="built_in">hash</span>-<span class="number">1</span> 和<span class="built_in">hash</span>-<span class="number">2</span>进行比对，如果相同，则可以判定信息没有被篡改，或者说一定是甲发送的信息</span><br></pre></td></tr></table></figure>



<h1 id="SSH传输层协议"><a href="#SSH传输层协议" class="headerlink" title="SSH传输层协议"></a>SSH传输层协议</h1><p><img src="image-20220617152725857.png" alt="image-20220617152725857"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">密钥交换算法：双方根据该算法生成一个对称加密的密钥，用于后续报文的加密</span><br><span class="line">公钥算法：用于用户认证时选择哪种算法进行非对称加密</span><br><span class="line">对称加密算法：用于报文在进行对称加密时采用哪种对称加密的算法</span><br><span class="line">消息认证算法：用于数据完整性的认证</span><br></pre></td></tr></table></figure>



<h1 id="用户认证原理"><a href="#用户认证原理" class="headerlink" title="用户认证原理"></a>用户认证原理</h1><ul>
<li>口令认证（账号密码认证）</li>
</ul>
<p><img src="image-20220617151729483.png" alt="image-20220617151729483"></p>
<ul>
<li>公钥认证（免密登录）</li>
</ul>
<p><img src="image-20220617151805850.png" alt="image-20220617151805850"></p>
<ul>
<li>免密登录虽然不用输入账号密码，但是需要事先将客户端的公钥保存在服务器中</li>
</ul>
<h1 id="SSH连接协议"><a href="#SSH连接协议" class="headerlink" title="SSH连接协议"></a>SSH连接协议</h1><p><img src="image-20220617152621092.png" alt="image-20220617152621092"></p>
]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>hello hexo -_-</title>
    <url>/2023/10/15/hello-hexo/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容1</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容2</p>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p>YzzCloud</p>
]]></content>
  </entry>
  <entry>
    <title>TCP/IP基础</title>
    <url>/2023/10/15/TCP-IP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>摘要：TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p>
<span id="more"></span>

<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h3 id="1-1对比"><a href="#1-1对比" class="headerlink" title="1.1对比"></a>1.1对比</h3><table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接类型</td>
<td>面向连接</td>
<td>面向无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>有序</td>
<td>数据包有序号</td>
<td>没有序号</td>
</tr>
<tr>
<td>使用场景</td>
<td>数据不能出任何问题</td>
<td>视频 音频</td>
</tr>
</tbody></table>
<ul>
<li><p>连接</p>
<ul>
<li>TCP需要通讯双方预先建立连接 三次握手 四次挥手</li>
<li>UDP不需要预先建立连接</li>
</ul>
</li>
<li><p>可靠性</p>
<ul>
<li>TCP需要确定每一个包的接收 丢包重发 效率低</li>
<li>UDP尽力交付数据 不需要确认数据包 丢包无法知道 也不重复 效率高</li>
</ul>
</li>
<li><p>有序</p>
<ul>
<li>TCP包有序号 可进行顺序控制 第一个包序号随机生成 之后的序号都和它有关</li>
<li>UDP包无序 无法纠正 只能在应用层进行验证</li>
</ul>
</li>
</ul>
<h2 id="二、三次握手"><a href="#二、三次握手" class="headerlink" title="二、三次握手"></a>二、三次握手</h2><h3 id="2-1图解"><a href="#2-1图解" class="headerlink" title="2.1图解"></a>2.1图解</h3><p><img src="image-20230729113206627.png" alt="image-20230729113206627"></p>
<h3 id="2-2说明"><a href="#2-2说明" class="headerlink" title="2.2说明"></a>2.2说明</h3><p><img src="image-20230729135210005.png" alt="image-20230729135210005"></p>
<h2 id="三、四次断开"><a href="#三、四次断开" class="headerlink" title="三、四次断开"></a>三、四次断开</h2><h3 id="3-1图解"><a href="#3-1图解" class="headerlink" title="3.1图解"></a>3.1图解</h3><p><img src="image-20230729135651868.png" alt="image-20230729135651868"></p>
<h3 id="3-2说明"><a href="#3-2说明" class="headerlink" title="3.2说明"></a>3.2说明</h3><p><strong><img src="image-20230729140242969.png" alt="image-20230729140242969"></strong></p>
]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>python 基础语法</title>
    <url>/2023/10/15/python-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>摘要:    description: 介绍了python基础语法</p>
<span id="more"></span>


<h1 id="02-基础语法"><a href="#02-基础语法" class="headerlink" title="02. 基础语法"></a>02. 基础语法</h1><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>由于计算机只能够识别1跟0两种信号，那么就需要我们将信息转换成计算机所能够理解的信号，</p>
<p>因此编码的本质就是人所能够理解的字符与计算机所能够理解的二进制之间的对应关系，也就是类似于密码本一样的东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">马   0000 0001</span><br><span class="line">琨   0000 0010</span><br><span class="line">琪   0000 0011</span><br></pre></td></tr></table></figure>

<p>不同的编码模式对于同一个字符可能会存在不同的对应关系</p>
<h3 id="1-2-ASCII编码"><a href="#1-2-ASCII编码" class="headerlink" title="1.2 ASCII编码"></a>1.2 ASCII编码</h3><blockquote>
<p><a href="http://www.lookuptables.com/">www.lookuptables.com</a></p>
</blockquote>
<p>最早期一种编码模式，采用一个字节来表示对应关系，由于一个字节等于8个bit的长度，共有256种对应方式</p>
<p>因此只能够对一些指令，常见的符号，以及数字和英文字符提供码位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A--65--01000001</span><br></pre></td></tr></table></figure>

<h3 id="1-3-GBK编码"><a href="#1-3-GBK编码" class="headerlink" title="1.3 GBK编码"></a>1.3 GBK编码</h3><p>GB2312，中国指定的编码标准，为中国的汉字提供了二进制的码位。</p>
<p>GBK编码就是在GB2312的基础上发展起来的，也为日韩相关的文字提供了二进制的码位</p>
<ul>
<li><p>使用一个字节来表示对应关系</p>
</li>
<li><p>使用两个字节来表示对应关系（16bit 65536）</p>
</li>
</ul>
<h3 id="1-4-UNICODE编码"><a href="#1-4-UNICODE编码" class="headerlink" title="1.4 UNICODE编码"></a>1.4 UNICODE编码</h3><p>万国码，为全球的每一个文字都提供了一个二进制的码位</p>
<ul>
<li><p>USC2，使用两个字节来表示对应关系</p>
</li>
<li><p>USC4，使用四个字节来表示对应关系（32bit 42.9亿）</p>
</li>
</ul>
<p>在进行存储和数据传输时，会浪费大量的空间</p>
<p>假设我们举一个非常极端的例子，假设使用ASCII编码存储一个G的A，此时对应的使用unicode编码要占用4个G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A--65--01000001  ASCII</span><br><span class="line">A--01000001 01000001 01000001 01000001 unicode</span><br></pre></td></tr></table></figure>

<p>在内存中处理数据时，一般都会采用unicode编码</p>
<h3 id="1-5-UTF-8编码"><a href="#1-5-UTF-8编码" class="headerlink" title="1.5 UTF-8编码"></a>1.5 UTF-8编码</h3><p>utf-8编码也可以为全球的每一个文字都提供了一个二进制的码位，但在unicode的基础上进行了压缩</p>
<p>使用一个字节来表示对应关系</p>
<p>使用两个字节来表示对应关系</p>
<p>使用三个字节来表示对应关系</p>
<p>使用四个字节来表示对应关系</p>
<p>因此UTF-8的编码适合进行数据的存储以及数据的传输</p>
<h3 id="1-6-乱码"><a href="#1-6-乱码" class="headerlink" title="1.6 乱码"></a>1.6 乱码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">马--<span class="number">65</span>--<span class="number">0</span>1000001  <span class="number">0</span>1000001 GBK</span><br><span class="line">       <span class="number">0</span>1000001  <span class="number">0</span>1000001 UTF-<span class="number">8</span>  </span><br><span class="line">       找不到就会出现乱码</span><br><span class="line">目前的文件默认采用的都是utf-<span class="number">8</span>的编码，如果想要改变默认的编码模式，可以在python文件的头部加上一段代码</span><br><span class="line"><span class="comment"># 默认的编码模式改为GBK</span></span><br><span class="line"><span class="comment"># -*- coding:GBK -*-  </span></span><br><span class="line">即便能够这样改变编码模式，但是建议还是采用UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>



<h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><h3 id="2-1-进制在python中的表示"><a href="#2-1-进制在python中的表示" class="headerlink" title="2.1 进制在python中的表示"></a>2.1 进制在python中的表示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制       int</span><br><span class="line">二进制       bin</span><br><span class="line">八进制       oct</span><br><span class="line">十六进制     hex</span><br></pre></td></tr></table></figure>



<h3 id="2-2-进制转换方法"><a href="#2-2-进制转换方法" class="headerlink" title="2.2 进制转换方法"></a>2.2 进制转换方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>将十进制转成二进制</span><br><span class="line">v1 = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(v1))</span><br><span class="line"><span class="number">0b1010</span></span><br><span class="line"><span class="number">2.</span>将十进制转成八进制</span><br><span class="line">v1 = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(v1))</span><br><span class="line"><span class="number">0o12</span></span><br><span class="line"><span class="number">3.</span>将十进制转成十六进制</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(v1))</span><br><span class="line"><span class="number">0xa</span></span><br><span class="line"><span class="number">4.</span>将<span class="number">2</span>进制转成十进制</span><br><span class="line">v1 = <span class="string">&#x27;0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(v1,base=<span class="number">2</span>))</span><br><span class="line"><span class="number">5.</span>将<span class="number">8</span>进制转成十进制</span><br><span class="line">v1 = <span class="string">&#x27;0o12&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(v1,base=<span class="number">8</span>))</span><br><span class="line"><span class="number">6.</span>将十六进制转成十进制</span><br><span class="line">v1 = <span class="string">&#x27;0xa&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(v1,base=<span class="number">16</span>))</span><br><span class="line"><span class="number">7.</span>将二进制转成十六进制</span><br><span class="line">v1 = <span class="string">&#x27;0b1010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>(v1,base=<span class="number">2</span>)))</span><br><span class="line"><span class="number">0xa</span></span><br><span class="line">v1 = <span class="number">0b1010</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(v1))</span><br></pre></td></tr></table></figure>



<h2 id="3-基本常用函数"><a href="#3-基本常用函数" class="headerlink" title="3. 基本常用函数"></a>3. 基本常用函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数就是一个功能的集合</span><br></pre></td></tr></table></figure>

<h3 id="3-1-print"><a href="#3-1-print" class="headerlink" title="3.1 print"></a>3.1 print</h3><h4 id="3-1-1-print函数的功能"><a href="#3-1-1-print函数的功能" class="headerlink" title="3.1.1 print函数的功能"></a>3.1.1 print函数的功能</h4><p>输出一段内容，显示给用户</p>
<h4 id="3-1-2-常用参数"><a href="#3-1-2-常用参数" class="headerlink" title="3.1.2 常用参数"></a>3.1.2 常用参数</h4><ul>
<li>end：输出内容之后默认采用的符号，默认是换行符\n</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;123&quot;,end=&quot;,&quot;)</span><br><span class="line">print(&quot;456&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>sep：输出多段内容之间连接的符号，默认是空格</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;123&quot;, &quot;456&quot;,sep=&quot;,&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-input"><a href="#3-2-input" class="headerlink" title="3.2 input"></a>3.2 input</h3><ul>
<li>作用：跟用户做一个交互，接收用户输入的一段内容，注意：通过input方法接收到的值是字符串类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(name)+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><h3 id="4-1-变量的本质"><a href="#4-1-变量的本质" class="headerlink" title="4.1 变量的本质"></a>4.1 变量的本质</h3><p>变量就是一种容器，指向某一块内存地址</p>
<p>假设现在我们将整个内存当成一个非常大的仓库，取件码 货物 货物实际存放的位置</p>
<p>完整的变量：变量名，变量值，内存地址</p>
<h5 id="4-2-变量定义-调用"><a href="#4-2-变量定义-调用" class="headerlink" title="4.2 变量定义&amp;调用"></a>4.2 变量定义&amp;调用</h5><p>变量必须先定义，再调用</p>
<p>定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">gender = <span class="string">&quot;male&quot;</span></span><br><span class="line">a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line">info = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">name:&#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(name)</span><br><span class="line"><span class="built_in">print</span>(info)</span><br></pre></td></tr></table></figure>



<h5 id="4-3-变量定义规则"><a href="#4-3-变量定义规则" class="headerlink" title="4.3 变量定义规则"></a>4.3 变量定义规则</h5><ul>
<li>变量名只能由字母、数字、下划线来组成</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ = <span class="number">123</span> <span class="comment">#错误的变量名</span></span><br><span class="line">name_1 = <span class="number">123</span> <span class="comment">#正确的变量名</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能以数字开头</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">1name = <span class="number">123</span> <span class="comment">#错误的变量名</span></span><br><span class="line">name1 = <span class="number">123</span> <span class="comment">#正确的变量名</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能用python中的关键字来作为变量名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> = <span class="number">123</span> <span class="comment">#错误的示范，语法上不会出错，但是会影响原有关键字的功能</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">print</span></span><br><span class="line"><span class="keyword">break</span> <span class="keyword">continue</span> <span class="keyword">pass</span>... //不要用</span><br></pre></td></tr></table></figure>

<h5 id="4-4-变量命名规范"><a href="#4-4-变量命名规范" class="headerlink" title="4.4 变量命名规范"></a>4.4 变量命名规范</h5><p>PEP8规范：业界定义的一种规范，理论上来讲不需要强制遵守，但是建议采用这种格式</p>
<p>在pycharm当中可以自动的检查代码是否符合PEP8的规范，使用快捷键Ctrl+Alt+L来进行调整</p>
<ul>
<li>在定义变量时，尽量使用英文，不要使用拼音的缩写</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xuehao = <span class="string">&quot;123456&quot;</span> <span class="comment">#错误的命名规范</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下划线连接：一般来说，定义变量，函数时采用下划线连接</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student_id = <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>驼峰体：定义类的时候采用驼峰体</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">StudentId = <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="4-5-变量的修改与删除"><a href="#4-5-变量的修改与删除" class="headerlink" title="4.5 变量的修改与删除"></a>4.5 变量的修改与删除</h5><ul>
<li>场景1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>场景2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">name = <span class="string">&quot;李四&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>场景3</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">new_name = name</span><br></pre></td></tr></table></figure>

<ul>
<li>场景4</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">new_name = name</span><br><span class="line">name = <span class="string">&quot;李四&quot;</span></span><br><span class="line">new_name = name</span><br></pre></td></tr></table></figure>

<ul>
<li>场景5</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">18</span></span><br><span class="line">age = <span class="built_in">str</span>(num)</span><br></pre></td></tr></table></figure>

<ul>
<li>场景6</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="keyword">del</span> name</span><br></pre></td></tr></table></figure>



<h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h3><p>在编写代码的时候，我们需要对某些内容进行注释，解释器会忽略注释后的代码，不会执行</p>
<ul>
<li><p>注释代码，程序运行时，不会执行已经被注释掉的代码</p>
<ul>
<li>单行注释</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(123)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多行注释</li>
</ul>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name = &quot;张三&quot;</span></span><br><span class="line"><span class="comment"># new_name = name</span></span><br><span class="line"><span class="comment"># name = &quot;李四&quot;</span></span><br><span class="line"><span class="comment"># new_name = name</span></span><br><span class="line"><span class="comment"># print(new_name,name)</span></span><br><span class="line"></span><br><span class="line">全部选中 Ctrl+/</span><br></pre></td></tr></table></figure>
</li>
<li><p>对一些变量或者方法做解释说明</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span>  <span class="comment"># 定义一个名为张三的姓名</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图片显示测试</title>
    <url>/2023/10/15/testimg/</url>
    <content><![CDATA[<p>description: -_-</p>
<p><img src="image-20231015214211675.png" alt="image-20231015214211675"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo-Next</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程基础</title>
    <url>/2023/10/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>摘要:   程序如何提升速度？</p>
<p>① 单线程串行：由CPU 和 IO 轮流执行；② 多线程并发（threading）③ 多CPU 并行（multiprocessing）④ 多机器并行；</p>
<span id="more"></span>

<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="操作系统发展史"><a href="#操作系统发展史" class="headerlink" title="操作系统发展史"></a>操作系统发展史</h3><p>操作系统的发展史，本质上就是不断地提高CPU利用率的过程</p>
<h2 id="多道技术"><a href="#多道技术" class="headerlink" title="多道技术"></a>多道技术</h2><p>单核实现并发的效果</p>
<p>1.I&#x2F;O的操作（输入，输出，网络传输）</p>
<p>2.计算数据</p>
<h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><p>根据顺序，依次执行，CPU的利用率非常低</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li>并发</li>
</ul>
<p>看起来像是在同时执行，就叫做并发</p>
<ul>
<li>并行</li>
</ul>
<p>实际上的确在同时执行，就叫做并行</p>
<p>所以，并行一定可以叫做并发，但是并发不一定叫做并行</p>
<ul>
<li>串行和并行</li>
</ul>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><ul>
<li>空间上的复用</li>
</ul>
<p>​	多个应用程序共用一套硬件</p>
<ul>
<li>时间上的复用</li>
</ul>
<p>​	在同一时间，同时做着很多事情：点外卖，洗衣服，学习</p>
<h3 id="cpu是如何切换的"><a href="#cpu是如何切换的" class="headerlink" title="cpu是如何切换的"></a>cpu是如何切换的</h3><p>1.I&#x2F;O操作的时候，主动释放CPU的使用权限</p>
<p>2.长时间占用，剥夺CPU的使用权限</p>
<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>程序是死的，进程是活的</p>
<ul>
<li>程序</li>
</ul>
<p>程序实际就相当于一大段功能代码的集合</p>
<ul>
<li>进程</li>
</ul>
<p>进程指的就是程序实际执行的过程</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>当多个进程同时执行时，需要分配CPU的资源，而这个分配过程不是随机的，而是遵循一定的规则，那这个规则就需要进程的调度算法</p>
<ul>
<li>先来先服务调度算法：对长作业有利</li>
<li>短作业优先调度算法：对短作业有利</li>
<li>时间片轮转法+多级反馈队列</li>
</ul>
<h2 id="进程与线程概述"><a href="#进程与线程概述" class="headerlink" title="进程与线程概述"></a>进程与线程概述</h2><h3 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h3><ul>
<li>进程指的就是程序执行的过程，线程是进程工作的最小单位</li>
</ul>
<p>假设应用程序相当于是一个工厂（生产东西-数据的），此时进程就相当于是工厂的车间，而线程就相当于是车间的工人，因此每个进程最少要存在一个线程</p>
<p>此时如果我们想要提高生产效率：1.扩车间 2.每个车间增加工人</p>
<p>进程和线程分别是在什么的基础上创建出来的？</p>
<p>进程是在程序的基础上申请额外的内存空间</p>
<p>线程是在进程的基础上增加线程</p>
<p>因此进程是比线程消耗资源更多的方式</p>
<h3 id="初识多进程、多线程"><a href="#初识多进程、多线程" class="headerlink" title="初识多进程、多线程"></a>初识多进程、多线程</h3><ul>
<li>多线程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="comment"># 在这个示例中，并没有缩短执行时间</span></span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())  <span class="comment"># 1687596183.341898（引入线程）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    t = threading.Thread(target=func, args=(i, ))   <span class="comment"># 子线程</span></span><br><span class="line">    t.start()   <span class="comment"># 线程已经准备就绪，可以被调度</span></span><br><span class="line">    <span class="comment"># 1687596183.341898</span></span><br><span class="line">    <span class="comment"># 1687596215.4531312</span></span><br><span class="line">    <span class="comment"># 1687596215.513087</span></span><br></pre></td></tr></table></figure>



<ul>
<li>多进程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个示例中，并没有缩短执行时间</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    <span class="built_in">print</span>(time.time())  <span class="comment"># 1687595289.1904593（引入进程）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        t = multiprocessing.Process(target=func, args=(i,))  <span class="comment"># 进程</span></span><br><span class="line">        t.start()  <span class="comment"># 进程已经准备就绪，可以被调度</span></span><br><span class="line"><span class="comment"># 1687596004.0196815</span></span><br><span class="line"><span class="comment"># 1687596022.0709853</span></span><br><span class="line"><span class="comment"># 1687596022.2699168        </span></span><br></pre></td></tr></table></figure>



<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process 是内置模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 24s---&gt;12s</span></span><br><span class="line"><span class="comment"># 在windows系统下，创建进程必须在if __name__ == &#x27;__main__&#x27;:下</span></span><br><span class="line"><span class="comment"># 这是因为在windows系统下，创建进程是以模块导入的形式进行创建</span></span><br><span class="line"><span class="comment"># 如果不在if __name__ == &#x27;__main__&#x27;:创建，每次导入都会重新创建一个进程，不断循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        p = Process(target=func, args=(i,))  <span class="comment"># 创建进程，注意target接的参数不要带括号，同时args跟的参数要加逗号（元组）</span></span><br><span class="line">        p.start() <span class="comment"># 启动进程</span></span><br><span class="line">    <span class="comment"># 在子进程执行的过程当中，主进程不会等到子进程执行完毕</span></span><br><span class="line">    <span class="comment"># print(time.time())</span></span><br></pre></td></tr></table></figure>

<ul>
<li>join方法</li>
</ul>
<p>通过该方法，可以让主进程等待子进程结束之后再执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process 是内置模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 24s---&gt;12s</span></span><br><span class="line"><span class="comment"># 在windows系统下，创建进程必须在if __name__ == &#x27;__main__&#x27;:下</span></span><br><span class="line"><span class="comment"># 这是因为在windows系统下，创建进程是以模块导入的形式进行创建</span></span><br><span class="line"><span class="comment"># 如果不在if __name__ == &#x27;__main__&#x27;:创建，每次导入都会重新创建一个进程，不断循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        p = Process(target=func, args=(i,))  <span class="comment"># 创建进程，注意target接的参数不要带括号，同时args跟的参数要加逗号（元组）</span></span><br><span class="line">        p.start() <span class="comment"># 启动进程</span></span><br><span class="line">        p.join()  <span class="comment"># 使用了join方法之后，代表主进程必须等待该进程结束之后才能执行</span></span><br><span class="line">    <span class="comment"># 在子进程执行的过程当中，主进程不会等到子进程执行完毕</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br></pre></td></tr></table></figure>

<p>问题：在使用join方法时，如果让多个子进程同时执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process 是内置模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 24s---&gt;12s</span></span><br><span class="line"><span class="comment"># 在windows系统下，创建进程必须在if __name__ == &#x27;__main__&#x27;:下</span></span><br><span class="line"><span class="comment"># 这是因为在windows系统下，创建进程是以模块导入的形式进行创建</span></span><br><span class="line"><span class="comment"># 如果不在if __name__ == &#x27;__main__&#x27;:创建，每次导入都会重新创建一个进程，不断循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        p = Process(target=func, args=(i,))  <span class="comment"># 创建进程，注意target接的参数不要带括号，同时args跟的参数要加逗号（元组）</span></span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start() <span class="comment"># 启动进程  # 使用了join方法之后，代表主进程必须等待该进程结束之后才能执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> p_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用join方法时，如果让多个子进程同时执行</span></span><br></pre></td></tr></table></figure>

<h3 id="进程互斥锁"><a href="#进程互斥锁" class="headerlink" title="进程互斥锁"></a>进程互斥锁</h3><ul>
<li>当多个进程同时操作一份数据时，会出现数据错乱的情况</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;查看当前余票为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, dic.get(<span class="string">&quot;ticket_num&quot;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">name</span>):</span><br><span class="line">    search(name)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dic.get(<span class="string">&quot;ticket_num&quot;</span>) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票成功！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">        dic[<span class="string">&quot;ticket_num&quot;</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(dic,f)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票失败！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        p = Process(target=buy,args=(i,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>解决办法：添加互斥锁：就是将原有的并行变成串行，牺牲了执行效率，但是保护了数据安全</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;查看当前余票为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, dic.get(<span class="string">&quot;ticket_num&quot;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">name,mutex</span>):</span><br><span class="line">    search(name)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    mutex.acquire()  <span class="comment"># 抢锁</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, mode=<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dic.get(<span class="string">&quot;ticket_num&quot;</span>) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票成功！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">        dic[<span class="string">&quot;ticket_num&quot;</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;config.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(dic, f)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户&#123;&#125;抢票失败！&quot;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">    mutex.release() <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mutex = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">        p = Process(target=buy, args=(i,mutex))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<h3 id="进程之间数据互相隔离"><a href="#进程之间数据互相隔离" class="headerlink" title="进程之间数据互相隔离"></a>进程之间数据互相隔离</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">666</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>



<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21s</span></span><br><span class="line"><span class="comment"># 23s</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num_list = [<span class="number">1000000000</span>, <span class="number">1000000000</span>]</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">        func(i)</span><br><span class="line">        t = Thread(target=func,args=(i,))</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br></pre></td></tr></table></figure>

<p>通过这个例子可以看到，通过多线程的方式没有办法提高程序的执行效率，没有缩短程序的执行时间，这是因为有GIL锁的存在</p>
<h3 id="GIL锁"><a href="#GIL锁" class="headerlink" title="GIL锁"></a>GIL锁</h3><ul>
<li>GIL锁其实是CPython当中设计的一个功能，它的目的就是让一个进程当中同一时间最多只有一个线程能被CPU调度</li>
<li>什么时候使用多进程，什么时候使用多线程？</li>
</ul>
<p>GIL锁让多线程丧失了多核优势，但是保证了数据安全</p>
<p>但并不是因为这样，多线程就没有了意义</p>
<p>&#x3D;&#x3D;I\O密集型：使用多线程，更多的文件存取，更多的网络传输&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;计算密集型：使用多进程，计算大量的数据&#x3D;&#x3D;</p>
<h3 id="同个进程的线程数据共享"><a href="#同个进程的线程数据共享" class="headerlink" title="同个进程的线程数据共享"></a>同个进程的线程数据共享</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">666</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=func)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抢GIL锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    n = num</span><br><span class="line">    num = n-<span class="number">1</span></span><br><span class="line"><span class="comment"># 释放GIL锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 开启了100个线程</span></span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br></pre></td></tr></table></figure>



<h3 id="线程互斥锁"><a href="#线程互斥锁" class="headerlink" title="线程互斥锁"></a>线程互斥锁</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抢GIL锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    n = num</span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># I/O操作</span></span><br><span class="line">    num = n-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 开启了100个线程</span></span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">mutex = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    n = num</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># I/O操作</span></span><br><span class="line">    num = n - <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">同时开启100个线程，此时每个线程要去抢夺两把锁，一把是GIL锁，一把是互斥锁</span></span><br><span class="line"><span class="string">此时线程遇到I/O操作会释放GIL锁，但是不会释放互斥锁</span></span><br><span class="line"><span class="string">必须等线程执行完毕才会释放互斥锁</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 开启了100个线程</span></span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t_list.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t_list:</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<h3 id="并发的实现网络编程"><a href="#并发的实现网络编程" class="headerlink" title="并发的实现网络编程"></a>并发的实现网络编程</h3><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.__len__() == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">        obj = subprocess.Popen(args=cmd,</span><br><span class="line">                               shell=<span class="literal">True</span>,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE</span><br><span class="line">                               )</span><br><span class="line">        std_out = obj.stdout.read()</span><br><span class="line">        std_err = obj.stderr.read()</span><br><span class="line">        result = std_out + std_err</span><br><span class="line">        total_size = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(result))</span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(total_size)</span><br><span class="line">        conn.send(result)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">    t = Thread(target=func, args=(conn,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    total_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, client.recv(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> size &lt; total_size:</span><br><span class="line">        res += client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">        size += <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>





<h2 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h2><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><ul>
<li><p>start() </p>
<blockquote>
<p>线程准备就绪，等待CPU的调度（并不是说线程开始执行的意思，只是准备好了，具体什么时候执行，要看CPU具体的调度）</p>
</blockquote>
</li>
<li><p>join()</p>
</li>
</ul>
<blockquote>
<p>等待当前的线程执行完毕，再接着向下执行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个示例中，并没有缩短执行时间</span></span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">100000000</span>, <span class="number">100000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())  <span class="comment"># 1687596183.341898（引入线程）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    t = threading.Thread(target=func, args=(i,))  <span class="comment"># 子线程</span></span><br><span class="line">    t.start()  <span class="comment"># 线程已经准备就绪，可以被调度</span></span><br><span class="line">    t.join()    <span class="comment"># 当前线程等待结束之后，其余线程开始执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment"># 1687772202.2158334</span></span><br><span class="line"><span class="comment"># 123                   # 主线程没有等待子线程结束</span></span><br><span class="line"><span class="comment"># 1687772205.4652102</span></span><br><span class="line"><span class="comment"># 1687772205.4678156</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1687772266.6596544</span></span><br><span class="line"><span class="comment"># 1687772268.207551</span></span><br><span class="line"><span class="comment"># 1687772269.7452214</span></span><br><span class="line"><span class="comment"># 123                   # join之后</span></span><br></pre></td></tr></table></figure>



<ul>
<li>os.getpid()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, active_count, current_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line"><span class="built_in">print</span>(os.getpid())</span><br><span class="line">hello world <span class="number">5324</span></span><br><span class="line"><span class="number">5324</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>current_thread()	</p>
<blockquote>
<p>.name 获得当前性能名称</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># print(&quot;hello world&quot;, os.getpid())</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>, current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Thread(target=func)</span><br><span class="line">t1 = Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">t1.start()</span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(os.getpid())</span></span><br><span class="line"><span class="built_in">print</span>(current_thread().name)</span><br><span class="line">hello world Thread-<span class="number">1</span> (func)</span><br><span class="line">hello world Thread-<span class="number">2</span> (func)</span><br><span class="line">MainThread</span><br></pre></td></tr></table></figure>

<ul>
<li>active_count()	查出当前进程有多少个线程在执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># print(&quot;hello world&quot;, os.getpid())</span></span><br><span class="line">    <span class="comment"># print(&quot;hello world&quot;, current_thread().name)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Thread(target=func)</span><br><span class="line">t2 = Thread(target=func)</span><br><span class="line">t1.start()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line"><span class="built_in">print</span>(active_count())</span><br><span class="line"><span class="comment"># t.join()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cloud&quot;</span>)</span><br><span class="line">hello world</span><br><span class="line">hello world2</span><br><span class="line"></span><br><span class="line">cloud</span><br></pre></td></tr></table></figure>



<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">100000000</span>, <span class="number">100000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    pool.submit(func, i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1687773791.3556776</span></span><br><span class="line"><span class="comment"># 1687773794.310415</span></span><br><span class="line"><span class="comment"># 1687773794.3211625</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===================================================================================</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line">num_list = [<span class="number">100000000</span>, <span class="number">100000000</span>]</span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num_list:</span><br><span class="line">    pool.submit(func, i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1687773955.9518306</span></span><br><span class="line"><span class="comment"># 1687773957.6569276</span></span><br><span class="line"><span class="comment"># 1687773959.1737313</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="主线程等待子线程"><a href="#主线程等待子线程" class="headerlink" title="主线程等待子线程"></a>主线程等待子线程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;主线程执行代码&quot;</span>)</span><br><span class="line"><span class="comment"># 从threading 库导入Thread类</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">threadFunc</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子线程 开始&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程函数参数是：<span class="subst">&#123;arg1&#125;</span>, <span class="subst">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子线程 结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Thread类的实例对象，并且指定新线程的入口函数</span></span><br><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">&#x27;参数1&#x27;</span>, <span class="string">&#x27;参数2&#x27;</span>)</span><br><span class="line">                )	<span class="comment"># # 只是创建了一个Thread实例对象， 但这时，新的线程还没有创建。</span></span><br><span class="line"><span class="comment"># 执行start 方法，就会创建新线程</span></span><br><span class="line"><span class="comment"># 并且新线程会去执行入口函数里的代码</span></span><br><span class="line"><span class="comment"># 这时候 这个进程 就有两个线程了</span></span><br><span class="line">thread.start()		<span class="comment"># 新的线程才创建成功，并开始执行 入口函数threadFunc 里面的代码</span></span><br><span class="line"><span class="comment"># 主线程的代码执行，子线程对象的join方法</span></span><br><span class="line"><span class="comment"># 就会等待子线程结束，才继续执行下面的代码</span></span><br><span class="line">thread.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;主线程结束&quot;</span>)</span><br><span class="line"><span class="comment"># 主线程执行代码</span></span><br><span class="line"><span class="comment"># 子线程 开始</span></span><br><span class="line"><span class="comment"># 线程函数参数是：参数1, 参数2</span></span><br><span class="line"><span class="comment"># 主线程结束     # 主线程没有等待子线程运行结束：---解决措施，.join() 等待</span></span><br><span class="line"><span class="comment"># 子线程 结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程执行代码</span></span><br><span class="line"><span class="comment"># 子线程 开始</span></span><br><span class="line"><span class="comment"># 线程函数参数是：参数1, 参数2</span></span><br><span class="line"><span class="comment"># 子线程 结束    # 主线程等待子线程运行结束</span></span><br><span class="line"><span class="comment"># 主线程结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="共享数据的访问控制"><a href="#共享数据的访问控制" class="headerlink" title="共享数据的访问控制"></a>共享数据的访问控制</h3><ul>
<li>多线程没有加锁	<ul>
<li>结果不正常</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">&#x27;byhy&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">theadidx,amount</span>):</span><br><span class="line">    balance =  bank[<span class="string">&#x27;byhy&#x27;</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">&#x27;byhy&#x27;</span>]  = balance + amount</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程 <span class="subst">&#123;theadidx&#125;</span> 结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主线程结束&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">&quot;byhy&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">1</span></span><br></pre></td></tr></table></figure>



<ul>
<li>单线程运行<ul>
<li>结果无误</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">&#x27;byhy&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">theadidx,amount</span>):</span><br><span class="line">    balance =  bank[<span class="string">&#x27;byhy&#x27;</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">&#x27;byhy&#x27;</span>]  = balance + amount</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    deposit (idx,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">&quot;byhy&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>





<ul>
<li>多线程加锁<ul>
<li>结果正确运行</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">&#x27;byhy&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bankLock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">theadidx,amount</span>):</span><br><span class="line">    <span class="comment"># 操作共享数据前，申请获取锁</span></span><br><span class="line">    bankLock.acquire()</span><br><span class="line">    </span><br><span class="line">    balance =  bank[<span class="string">&#x27;byhy&#x27;</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">&#x27;byhy&#x27;</span>]  = balance + amount</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程 <span class="subst">&#123;theadidx&#125;</span> 结束&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 操作完共享数据后，申请释放锁</span></span><br><span class="line">    bankLock.release()</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主线程结束&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">&quot;byhy&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>Lock 对象的acquire方法 是申请锁。</p>
<p>每个线程在 操作共享数据对象之前，都应该 申请获取操作权，也就是 调用该 共享数据对象对应的锁对象的acquire方法。</p>
<p>如果线程A 执行如下代码，调用acquire方法的时候，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bankLock.acquire()</span><br></pre></td></tr></table></figure>

<p>别的线程B 已经申请到了这个锁， 并且还没有释放，那么 线程A的代码就在此处 等待 线程B 释放锁，不去执行后面的代码。</p>
<p>直到线程B 执行了锁的 release 方法释放了这个锁， 线程A 才可以获取这个锁，就可以执行下面的代码了。</p>
<p>如果这时线程B 又执行 这个锁的acquire方法， 就需要等待线程A 执行该锁对象的release方法释放锁， 否则也会等待，不去执行后面的代码。</p>
<p>多进程</p>
<p>Python 官方解释器 的每个线程要获得执行权限，必须获取一个叫 GIL （全局解释器锁） 的东西。</p>
<p>这就导致了 Python 的多个线程 其实 并不能同时使用 多个CPU核心。</p>
<p>所以如果是计算密集型的任务，不能采用多线程的方式。</p>
<p>大家可以运行一下如下代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="comment"># 启动10个线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Thread(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>



<p><img src="image-20230626195918984.png" alt="image-20230626195918984"></p>
<p>如果需要利用电脑多个CPU核心的运算能力，可以使用Python的多进程库，如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        p = Process(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>

<p>运行后，打开任务管理器，可以发现 有3个Python进程，其中主进程CPU占用率为0，两个子进程CPU各占满了一个核心的运算能力。</p>
<p><img src="image-20230626200335697.png" alt="image-20230626200335697"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>vxlan基础介绍</title>
    <url>/2023/10/17/vxlan%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>description：</p>
<blockquote>
<p>VXLAN是一种网络虚拟化技术，可以改进大型云计算在部署时的扩展问题，是对VLAN的一种扩展。VXLAN是一种功能强大的工具，可以穿透三层网络对二层进行扩展。它可通过封装流量并将其扩展到第三层网关，以此来解决VMS（虚拟内存系统）的可移植性限制，使其可以访问在外部IP子网上的服务器。</p>
</blockquote>
<span id="more"></span>

<h1 id="vxlan初试"><a href="#vxlan初试" class="headerlink" title="vxlan初试"></a>vxlan初试</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="def"><a href="#def" class="headerlink" title="def"></a>def</h3><p>&#x3D;&#x3D;大二层&#x3D;&#x3D;</p>
<ul>
<li>虚拟机摆脱地理位置的限制自由迁移，构建跨地理区域的大二层网络。</li>
<li>要求网络横向流量提供无阻塞的能力</li>
<li>构建跨地理区域的服务器集群，提高系统容灾能力</li>
</ul>
<ol>
<li>一种点到点的隧道技术，隧道本质是对报文的重新封装，利用封装后的信息进行报文的转发。</li>
<li>vxlan是无控制平面的隧道技术。【有控制那个面的隧道技术：LSP（LDP&#x2F;BGP)，IPsec VPN(IKEv1,IKEv2), L2TP, SSL VPN ,VPLS】</li>
<li>实际上vxlan可以利用evn，evpn协议，sdn控制器来充当它的控制平面。</li>
<li>vxlan能实现2层互访（同子网互访），3层互访，也可以和传统vlan网络结合组网部署。</li>
<li>基于IP的封装，封装的对象始终是数据帧。</li>
</ol>
<h3 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h3><ul>
<li>Point of Delivery </li>
<li>既可以是物理的，也可以说逻辑的数据中心功能模块，一个POD，可以包含机柜、服务器及网络设备、以及相应的基础设施。</li>
</ul>
<p>&#x3D;&#x3D;传统数据中心架构网络&#x3D;&#x3D;</p>
<p><img src="image-20230720195825429.png" alt="image-20230720195825429"></p>
<p>传统网络大不起来？</p>
<ol>
<li>STP阻塞链路，浪费带宽</li>
<li>用CSS，M-LAG，纯二层网络广播泛洪范围太长，所有设备都要维护MAC地址表，表项容量存在DC扩容的瓶颈。</li>
</ol>
<p>云计算时代网络设计？（胖数据网 | Spnie+leaf组网）</p>
<ol>
<li>纯IP网络</li>
<li>扁平化</li>
<li>无阻赛链路</li>
<li>可靠，可扩展</li>
<li>大二层</li>
<li>报文转发不超过三台设备</li>
</ol>
<p><img src="image-20230720202038590.png" alt="image-20230720202038590"></p>
<p><img src="image-20230720202618943.png" alt="image-20230720202618943"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="NVE"><a href="#NVE" class="headerlink" title="NVE"></a>NVE</h3><ul>
<li><p>networkl virtualization edge：</p>
</li>
<li><p>网络虚拟化边缘设备，进行vxlan封装和解封装的设备。</p>
</li>
<li><p>位于overlay网络的边界，实现二、三层的虚拟化功能。</p>
</li>
</ul>
<h3 id="vxlan"><a href="#vxlan" class="headerlink" title="vxlan"></a>vxlan</h3><p>virtual extensible lan</p>
<ul>
<li>虚拟可扩展局域网</li>
<li>通过LMAC in udp 的报文封装方式，实现基于IP overlay的虚拟局域网</li>
<li>vxlan网络中的NVE以VTEP进行标识</li>
</ul>
<h3 id="VTEP"><a href="#VTEP" class="headerlink" title="VTEP"></a>VTEP</h3><ul>
<li>vxlan tunnel endpoint </li>
<li>vxlan隧道端点</li>
<li>每一个NVE至少有一个VTEP，VTEP使用NVE的IP地址表示</li>
<li>两个VTEP可以确定一条vxlan隧道</li>
</ul>
<p><img src="image-20230720205538515.png" alt="image-20230720205538515"></p>
<h3 id="逻辑抽象"><a href="#逻辑抽象" class="headerlink" title="逻辑抽象"></a>逻辑抽象</h3><p><img src="image-20230720205715739.png" alt="image-20230720205715739"></p>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p><img src="image-20230720210338414.png" alt="image-20230720210338414"></p>
<h3 id="vni"><a href="#vni" class="headerlink" title="vni"></a>vni</h3><ul>
<li>表示不同的广播域</li>
</ul>
<h3 id="udp-port"><a href="#udp-port" class="headerlink" title="udp port"></a>udp port</h3><ul>
<li>通过原始帧的SMAC+DMAC hash 后的值。</li>
<li>Dport 4789 代表vxlan</li>
<li>目前ensp 的sport 和dport 都是4789</li>
</ul>
<p>添加udp封装的原因？</p>
<p>- </p>
<p><img src="image-20230720210745483.png" alt="image-20230720210745483"></p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>vxlan？什么样的流量需要vxlan需要封装</p>
]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>vxlan</tag>
      </tags>
  </entry>
  <entry>
    <title>网络自动化模块paramiko</title>
    <url>/2023/10/18/%E7%BD%91%E7%BB%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A8%A1%E5%9D%97paramiko/</url>
    <content><![CDATA[<p>介绍：Paramiko是基于Python实现的SSH2远程安全连接，支持认证及密钥方式，可实现远程命令执行、文件传输、中间SSH代理等功能。</p>
<p>通俗的讲:Python的Paramiko依赖库，可以帮助开发者通过代码的方式完成对远程服务器的文件上传、文件下载操作，也可以对远程服务器输入操作命令。</p>
<span id="more"></span>





<h1 id="网络自动化相关模块"><a href="#网络自动化相关模块" class="headerlink" title="网络自动化相关模块"></a>网络自动化相关模块</h1><h1 id="paramiko基础"><a href="#paramiko基础" class="headerlink" title="paramiko基础"></a>paramiko基础</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;HUAWEI&gt;system-view immediately </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[HUAWEI]</span><br><span class="line">-----------------</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种方式打开SSH会话通道</span></span><br><span class="line"><span class="comment"># 1.transport</span></span><br><span class="line"><span class="comment"># 2.SSHclient(集成了transport)</span></span><br><span class="line"></span><br><span class="line">ssh_client = paramiko.SSHClient()</span><br><span class="line">ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 默认使用账号密码进行用户认证时，需要先获取服务器的公钥，服务器将公钥发送给客户端时，客户端默认不会立即接收该公钥</span></span><br><span class="line"><span class="comment"># 而set_missing_host_key_policy(paramiko.AutoAddPolicy())的作用就是让我们可以不输入yes or no的情况下自动把公钥保存在本地</span></span><br><span class="line">ssh_client.connect(hostname=<span class="string">&quot;192.168.100.1&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">vty = ssh_client.invoke_shell()</span><br><span class="line">res = vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&quot;N\n&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line">res = vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&quot;screen-length 0 temporary\n&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line">vty.send(<span class="string">&quot;dis cu\n&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">res = vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h1 id="SFTP基础"><a href="#SFTP基础" class="headerlink" title="SFTP基础"></a>SFTP基础</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>第一种方式</span><br><span class="line"><span class="comment"># 2. 使用transport打开SSH会话通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tran = paramiko.Transport((&quot;192.168.100.1&quot;, 22))</span></span><br><span class="line"><span class="comment"># tran.connect(username=&quot;python&quot;, password=&quot;Huawei@123&quot;)</span></span><br><span class="line"><span class="comment"># sftp = paramiko.SFTPClient.from_transport(tran)  # 从SSH会话的通道中建立sftp会话的通道</span></span><br><span class="line"><span class="comment"># sftp.get(&quot;/vrpcfg.cfg&quot;, r&quot;E:\devops\pythonProject\CE1.cfg&quot;)</span></span><br><span class="line"><span class="comment"># sftp.put(r&quot;E:\devops\pythonProject\CE1.cfg&quot;, &quot;/TEST.cfg&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在执行sftp get下载时，如果下载后的名称相同，后面下载的文件会将前面下载的文件覆盖掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cfcard:/vrpcfg.cfg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：在写路径时不要敲额外的字符，否则会报文件不存在的错误</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>第二种方式</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transport</span>():</span><br><span class="line">    ssh_session = paramiko.SSHClient()</span><br><span class="line">    <span class="comment"># 在使用口令认证进行ssh连接时，客户端会先向请求服务端的公钥，这一条命令的作用就是</span></span><br><span class="line">    <span class="comment"># 让我们在不输入yes/no的情况下将服务端的公钥保存在本地</span></span><br><span class="line">    ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_session.connect(hostname=<span class="string">&quot;192.168.100.1&quot;</span>,port=<span class="number">22</span>,username=<span class="string">&quot;python&quot;</span>,password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">    <span class="comment"># 在ssh会话通道的基础上，打开命令行交互的通道</span></span><br><span class="line">    <span class="keyword">return</span> ssh_session</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    tran = transport()</span><br><span class="line">    res = tran.get_transport()</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(res)</span><br><span class="line">    <span class="comment"># get方法，将远程的文件下载到本地：remotepath localpath</span></span><br><span class="line">    remote = <span class="string">&quot;/vrpcfg.cfg&quot;</span></span><br><span class="line">    local = <span class="string">r&quot;E:\devops\Phase 2\project\自动化编程\自动化相关模块\CE2.txt&quot;</span></span><br><span class="line">    <span class="comment"># sftp.get(remote,local)</span></span><br><span class="line">    remote_put = <span class="string">&quot;CE1.cfg&quot;</span></span><br><span class="line">    <span class="comment"># sftp.put(local,remote_put)</span></span><br><span class="line">    sftp.get(remote,local)</span><br><span class="line">    sftp.close()</span><br></pre></td></tr></table></figure>



<h1 id="补充-OS模块"><a href="#补充-OS模块" class="headerlink" title="补充 OS模块"></a>补充 OS模块</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path_dirs = <span class="string">&quot;files&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path_dirs):</span><br><span class="line">    os.makedirs(path_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># path = os.path.abspath(__file__)  # 获取当前py文件的绝对路径</span></span><br><span class="line"><span class="comment"># root_path = os.path.dirname(path)  # 获取path路径的上一级目录</span></span><br><span class="line"><span class="comment"># new_path = os.path.join(root_path, &quot;files&quot;)  # 实现路径的拼接,将root_path 与 files进行路径的拼接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path)</span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.使用os模块来获取当前执行文件的绝对路径</span></span><br><span class="line">v1 = os.path.abspath(__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用os模块来获取上一级的目录</span></span><br><span class="line">v2 = os.path.dirname(v1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用os模块完成路径的拼接</span></span><br><span class="line">v3 = os.path.join(v2,<span class="string">&quot;CE1.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(v3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，本地路径可以写成这样的形式</span></span><br><span class="line">local =  os.path.join(os.path.dirname(os.path.abspath(__file__)),<span class="string">&quot;CE1.txt&quot;</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>利用os模块自动获取当前路径，以及使用datetime模块修改文件名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">path_dirs = <span class="string">&quot;files&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path_dirs):</span><br><span class="line">    os.makedirs(path_dirs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># path = os.path.abspath(__file__)  # 获取当前py文件的绝对路径</span></span><br><span class="line"><span class="comment"># root_path = os.path.dirname(path)  # 获取path路径的上一级目录</span></span><br><span class="line"><span class="comment"># new_path = os.path.join(root_path, &quot;files&quot;)  # 实现路径的拼接,将root_path 与 files进行路径的拼接</span></span><br><span class="line">time_now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d-%H-%M-%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>, time_now + <span class="string">&quot;-CE1.cfg&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tran = paramiko.Transport((<span class="string">&quot;192.168.100.1&quot;</span>, <span class="number">22</span>))</span><br><span class="line">tran.connect(username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">sftp = paramiko.SFTPClient.from_transport(tran)  <span class="comment"># 从SSH会话的通道中建立sftp会话的通道</span></span><br><span class="line">sftp.get(<span class="string">&quot;/vrpcfg.cfg&quot;</span>, path)</span><br><span class="line"><span class="comment"># sftp.put(r&quot;E:\devops\pythonProject\CE1.cfg&quot;, &quot;/TEST.cfg&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="批量配置"><a href="#批量配置" class="headerlink" title="批量配置"></a>批量配置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&quot;N\n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    vty.send(<span class="string">&quot;system-view im \n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [&quot;192.168.100.&#123;&#125;&quot;.format(i) for i in range(1, 4)]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">num</span>):</span><br><span class="line">    data_list = [&#123;<span class="string">f&quot;CE<span class="subst">&#123;i&#125;</span>&quot;</span>: &#123;<span class="string">&quot;ip&quot;</span>: <span class="string">f&quot;192.168.100.<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">&quot;port&quot;</span>: <span class="number">22</span>, <span class="string">&quot;username&quot;</span>: <span class="string">&quot;python&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;Huawei@123&quot;</span>&#125;&#125; <span class="keyword">for</span></span><br><span class="line">                 i <span class="keyword">in</span></span><br><span class="line">                 <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">        res = ssh_config(i[<span class="string">f&quot;CE<span class="subst">&#123;num&#125;</span>&quot;</span>][<span class="string">&quot;ip&quot;</span>], <span class="number">22</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;Huawei@123&quot;</span>, <span class="string">&quot;sftp.txt&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run(num=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&quot;N\n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    vty.send(<span class="string">&quot;system-view im \n&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">ip, port, username, password, sysname</span>):</span><br><span class="line">    time_now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d-%H-%M-%S&quot;</span>)</span><br><span class="line">    path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>, time_now + <span class="string">f&quot;-<span class="subst">&#123;sysname&#125;</span>.cfg&quot;</span>)</span><br><span class="line">    tran = paramiko.Transport((ip, port))</span><br><span class="line">    tran.connect(username=username, password=password)</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(tran)</span><br><span class="line">    sftp.get(<span class="string">&quot;/vrpcfg.cfg&quot;</span>, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [&quot;192.168.100.&#123;&#125;&quot;.format(i) for i in range(1, 4)]</span></span><br><span class="line"><span class="comment"># def run(num):</span></span><br><span class="line"><span class="comment">#     data_list = [&#123;f&quot;CE&#123;i&#125;&quot;: &#123;&quot;ip&quot;: f&quot;192.168.100.&#123;i&#125;&quot;, &quot;port&quot;: 22, &quot;username&quot;: &quot;python&quot;, &quot;password&quot;: &quot;Huawei@123&quot;&#125;&#125; for</span></span><br><span class="line"><span class="comment">#                  i in</span></span><br><span class="line"><span class="comment">#                  range(1, 4)]</span></span><br><span class="line"><span class="comment">#     for i in data_list:</span></span><br><span class="line"><span class="comment">#         res = ssh_config(i[f&quot;CE&#123;num&#125;&quot;][&quot;ip&quot;], 22, &quot;python&quot;, &quot;Huawei@123&quot;, &quot;sftp.txt&quot;)</span></span><br><span class="line"><span class="comment">#         print(res)</span></span><br><span class="line"><span class="comment">#         num += 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_list = [&#123;<span class="string">&quot;ip&quot;</span>: <span class="string">f&quot;192.168.100.<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">&quot;sysname&quot;</span>: <span class="string">f&quot;CE<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">&quot;username&quot;</span>: <span class="string">&quot;python&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;Huawei@123&quot;</span>&#125; <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">             <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">    download(ip=i[<span class="string">&quot;ip&quot;</span>], port=<span class="number">22</span>, sysname=i[<span class="string">&quot;sysname&quot;</span>], username=i[<span class="string">&quot;username&quot;</span>], password=i[<span class="string">&quot;password&quot;</span>])</span><br></pre></td></tr></table></figure>



<h1 id="paramiko进阶"><a href="#paramiko进阶" class="headerlink" title="paramiko进阶"></a>paramiko进阶</h1><ul>
<li>第一期</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 在使用paramiko进行ssh登录时，可能会存在网络或者设备故障的问题</span></span><br><span class="line"><span class="comment"># 2. 如何判断设备登录成功</span></span><br><span class="line"><span class="comment"># 3. 如何保证回显完毕</span></span><br><span class="line"><span class="comment"># 4. 如何判断进入了系统视图</span></span><br><span class="line"><span class="comment"># 5. 如何判断命令执行成功</span></span><br><span class="line"><span class="comment"># 6. 命令执行成功之后，如何判断正确的返回了用户视图</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip</span>):</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.ip&#125;</span>链接失败&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetMarkError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GetMarkError&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSH</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.session = <span class="literal">None</span></span><br><span class="line">        self.vty = <span class="literal">None</span></span><br><span class="line">        self.login = <span class="literal">False</span></span><br><span class="line">        self.config = <span class="literal">False</span></span><br><span class="line">        self.old_mark = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        ssh_session = paramiko.SSHClient()</span><br><span class="line">        ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh_session.connect(hostname=self.ip, port=self.port, username=self.username, password=self.password)</span><br><span class="line">        self.session = ssh_session</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_vty</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.vty = self.session.invoke_shell()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mark</span>(<span class="params">self, output: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        pat = re.<span class="built_in">compile</span>(<span class="string">&quot;&lt;.+?&gt;&quot;</span>)  <span class="comment"># 创建一个正则表达式的对象</span></span><br><span class="line">        res = pat.findall(output)</span><br><span class="line">        <span class="keyword">if</span> res.__len__() != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> GetMarkError</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mark = self.old_mark = res[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_device</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.transport()</span><br><span class="line">            self.open_vty()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">raise</span> LoginError(self.ip)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        output = self.vty.recv(<span class="number">65535</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        self.get_mark(output)</span><br><span class="line">        self.login = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_result</span>(<span class="params">self, nbytes, interval=<span class="number">1</span></span>):</span><br><span class="line">        pat = re.<span class="built_in">compile</span>(self.mark)</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res = self.vty.recv(nbytes).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            ret += res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pat.search(res):</span><br><span class="line">                self.vty.send(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                time.sleep(interval)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.vty.send(command + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        res = self.recv_result(<span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_mode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.mark = <span class="string">&quot;\[.+?\]&quot;</span></span><br><span class="line">        self.test_command(<span class="string">&quot;system-view&quot;</span>)</span><br><span class="line">        self.config = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">self</span>):</span><br><span class="line">        self.mark = self.old_mark</span><br><span class="line">        <span class="keyword">return</span> self.test_command(<span class="string">&quot;return&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params">self, command: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config:</span><br><span class="line">            self.config_mode()</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> command:</span><br><span class="line">            res = self.test_command(i)</span><br><span class="line">            ret += res</span><br><span class="line">        ret += self.test_command(<span class="string">&quot;commit&quot;</span>)</span><br><span class="line">        ret += self.exit()</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ssh_client = SSH(ip=<span class="string">&quot;192.168.100.1&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Admin@123&quot;</span>)</span><br><span class="line">    res = ssh_client.send_command([<span class="string">&quot;interface GE1/0/0&quot;</span>, <span class="string">&quot;des ytedu&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<ul>
<li>第二期</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 在使用paramiko进行ssh登录时，可能会存在网络或者设备故障的问题</span></span><br><span class="line"><span class="comment"># 2. 如何判断设备登录成功</span></span><br><span class="line"><span class="comment"># 3. 如何保证回显完毕</span></span><br><span class="line"><span class="comment"># 4. 如何判断进入了系统视图</span></span><br><span class="line"><span class="comment"># 5. 如何判断命令执行成功</span></span><br><span class="line"><span class="comment"># 6. 命令执行成功之后，如何判断正确的返回了用户视图</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginError</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.ip&#125;</span> Login Error&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetMarkError</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.ip&#125;</span> GetMarkError&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSH</span>:</span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.ssh_session = <span class="literal">None</span></span><br><span class="line">        self.vty = <span class="literal">None</span></span><br><span class="line">        self.login = <span class="literal">False</span></span><br><span class="line">        self.config = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 创建SSH会话，并设置SSH会话的标识符</span></span><br><span class="line">        ssh_session = paramiko.SSHClient()</span><br><span class="line">        ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh_session.connect(hostname=self.ip, port=self.port, username=self.username,</span><br><span class="line">                            password=self.password)</span><br><span class="line">        self.ssh_session = ssh_session</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_vty</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 基于SSH会话建立命令行交互的会话，并设置标识符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.ssh_session:</span><br><span class="line">            self.transport()</span><br><span class="line">        self.vty = self.ssh_session.invoke_shell()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mark</span>(<span class="params">self, arg: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="comment"># 创建正则对象，匹配&lt;设备名称&gt;，如果匹配到说明登录成功，没有匹配到说明登陆失败，抛出异常</span></span><br><span class="line">        <span class="comment"># 设置mark标识符，此时代表是设备名称</span></span><br><span class="line">        pat = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;.+?&gt;&#x27;</span>)</span><br><span class="line">        res = pat.findall(arg)</span><br><span class="line">        <span class="keyword">if</span> res.__len__() == <span class="number">1</span>:</span><br><span class="line">            self.mark = self.old_mark = res[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># print(self.mark)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> GetMarkError(self.ip)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_device</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 创建设备登录的方法，并判断登录是否成功</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.transport()</span><br><span class="line">            self.open_vty()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">raise</span> LoginError(self.ip)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        content = self.vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="comment"># 将回显信息传入get_mark函数进行判断登录是否成功</span></span><br><span class="line">        self.get_mark(content)</span><br><span class="line">        self.login = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_result</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 创建正则对象，匹配&lt;设备名称&gt;，如果匹配到说明回显完整，没有匹配到说明回显不完整，继续敲空格</span></span><br><span class="line">        <span class="comment"># 将完整的回显返回出来</span></span><br><span class="line">        pat = re.<span class="built_in">compile</span>(self.mark)</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            content = self.vty.recv(<span class="number">99999</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(content)</span><br><span class="line">            ret += content</span><br><span class="line">            <span class="keyword">if</span> pat.search(content):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.vty.send(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 创建一个执行命令的方法，并调用recv_result()判断回显是否完整，并接收返回出的完整回显</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.vty.send(command + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        res = self.recv_result()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_mode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个进入系统视图的方法，并修改mark标识符匹配[~设备名]，如果匹配到说明成功进入系统视图</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.mark = <span class="string">&quot;\[.+?\]&quot;</span></span><br><span class="line">        self.send_command(<span class="string">&quot;system-view&quot;</span>)</span><br><span class="line">        self.config = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个返回用户视图的方法，修改mark标识符为&lt;设备名称&gt;，如果能匹配到则表明回到了用户视图</span></span><br><span class="line">        self.mark = self.old_mark</span><br><span class="line">        <span class="keyword">return</span> self.send_command(<span class="string">&quot;return&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_command</span>(<span class="params">self, command: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 创建一个执行命令的方法，执行完每一条命令都将结果拼接在ret变量中，最终返回完整的回显</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config:</span><br><span class="line">            self.config_mode()</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> command:</span><br><span class="line">            ret += self.send_command(i)</span><br><span class="line">        ret += self.send_command(<span class="string">&quot;commit&quot;</span>)</span><br><span class="line">        ret += self.exit()</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = SSH(ip=<span class="string">&quot;192.168.100.1&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Admin@123&quot;</span>)</span><br><span class="line">    res = a.config_command([<span class="string">&quot;interface G1/0/0&quot;</span>, <span class="string">&quot;des ytedu&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>



<h1 id="pysnmp"><a href="#pysnmp" class="headerlink" title="pysnmp"></a>pysnmp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = getCmd(SnmpEngine(),</span><br><span class="line">           UsmUserData(userName=<span class="string">&quot;admin&quot;</span>, authKey=<span class="string">&quot;Huawei@123&quot;</span>, privKey=<span class="string">&quot;Huawei@123&quot;</span>,</span><br><span class="line">                       authProtocol=usmHMACSHAAuthProtocol, privProtocol=usmAesCfb128Protocol),</span><br><span class="line">           UdpTransportTarget((<span class="string">&quot;192.168.100.1&quot;</span>, <span class="number">161</span>)),</span><br><span class="line">           ContextData(),</span><br><span class="line">           ObjectType(ObjectIdentity(<span class="string">&quot;1.3.6.1.2.1.1.5.0&quot;</span>)))</span><br><span class="line">errorIndication, errorStatus, errorIndex, varBinds =<span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> varBinds:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i).split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>].strip())</span><br></pre></td></tr></table></figure>

<ul>
<li>通过pysnmp获取设备名称，然后进行配置文件的下载</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">name</span>):</span><br><span class="line">    tran = paramiko.Transport((<span class="string">&#x27;192.168.100.1&#x27;</span>, <span class="number">22</span>))</span><br><span class="line">    tran.connect(username=<span class="string">&quot;python&quot;</span>,password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(tran)</span><br><span class="line">    <span class="comment"># get方法，将远程的文件下载到本地：remotepath localpath</span></span><br><span class="line">    now = datetime.now().strftime(<span class="string">&quot;%Y_%m_%d_%H_%M_%S&quot;</span>)+<span class="string">f&quot;_<span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">    remote = <span class="string">&quot;/vrpcfg.cfg&quot;</span></span><br><span class="line"></span><br><span class="line">    local = os.path.join(os.path.dirname(os.path.abspath(__file__)),now)</span><br><span class="line">    remote_put = <span class="string">&quot;CE1.cfg&quot;</span></span><br><span class="line">    <span class="comment"># sftp.put(local,remote_put)</span></span><br><span class="line">    sftp.get(remote,local)</span><br><span class="line">    sftp.close()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">snmp</span>():</span><br><span class="line">    get = getCmd(SnmpEngine(),</span><br><span class="line">                 UsmUserData(userName=<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                             authKey=<span class="string">&quot;Huawei@123&quot;</span>,</span><br><span class="line">                             privKey=<span class="string">&quot;Huawei@123&quot;</span>,</span><br><span class="line">                             authProtocol=usmHMACSHAAuthProtocol,</span><br><span class="line">                             privProtocol=usmAesCfb128Protocol),</span><br><span class="line">                 UdpTransportTarget((<span class="string">&quot;192.168.100.1&quot;</span>,<span class="number">161</span>)),</span><br><span class="line">                                    ContextData(),</span><br><span class="line">                             ObjectType(ObjectIdentity(<span class="string">&#x27;1.3.6.1.2.1.1.5.0&#x27;</span>)))</span><br><span class="line">    a, b, c, d = <span class="built_in">next</span>(get)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">        res = <span class="built_in">str</span>(i).split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arg = snmp()</span><br><span class="line">    download(arg)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="ssh大通道建立连接"><a href="#ssh大通道建立连接" class="headerlink" title="ssh大通道建立连接"></a>ssh大通道建立连接</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line">ssh_client = paramiko.SSHClient()</span><br><span class="line">ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 默认使用账号密码进行用户认证时，需要先获取服务器的公钥，服务器将公钥发送给客户端时，客户端默认不会立即接收该公钥</span></span><br><span class="line"><span class="comment"># 而set_missing_host_key_policy(paramiko.AutoAddPolicy())的作用就是让我们可以不输入yes or no的情况下自动把公钥保存在本地</span></span><br><span class="line">ssh_client.connect(hostname=<span class="string">&quot;192.168.56.100&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line"><span class="comment"># 传输命令 打开命令行交互小通道</span></span><br><span class="line">vty = ssh_client.invoke_shell()</span><br><span class="line"><span class="comment"># 拉取回显信息</span></span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Warning: The initial password poses security risks.</span></span><br><span class="line"><span class="string">The password needs to be changed. Change now? [Y/N]:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line">ssh_client = paramiko.SSHClient()</span><br><span class="line">ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># 默认使用账号密码进行用户认证时，需要先获取服务器的公钥，服务器将公钥发送给客户端时，客户端默认不会立即接收该公钥</span></span><br><span class="line"><span class="comment"># 而set_missing_host_key_policy(paramiko.AutoAddPolicy())的作用就是让我们可以不输入yes or no的情况下自动把公钥保存在本地</span></span><br><span class="line">ssh_client.connect(hostname=<span class="string">&quot;192.168.56.100&quot;</span>, port=<span class="number">22</span>, username=<span class="string">&quot;python&quot;</span>, password=<span class="string">&quot;Huawei@123&quot;</span>)</span><br><span class="line"><span class="comment"># 传输命令 打开命令行交互小通道</span></span><br><span class="line">vty = ssh_client.invoke_shell()</span><br><span class="line"><span class="comment"># 拉取回显信息</span></span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&#x27;N\n&#x27;</span>)  <span class="comment"># 内部自动转码</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">vty.send(<span class="string">&#x27;screen-length 0 temporary\n&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">vty.send(<span class="string">&#x27;dis cu\n&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">res = vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>







<h2 id="批量配置sftp"><a href="#批量配置sftp" class="headerlink" title="批量配置sftp"></a>批量配置sftp</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&#x27;N\n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    vty.send(<span class="string">&#x27;system-view im \n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [&#x27;192.168.56.&#123;&#125;&#x27;.format(i) for i in range(100, 130, 10)]</span></span><br><span class="line"><span class="comment"># print(data_list)</span></span><br><span class="line"><span class="comment"># data_list = [&#123;&#x27;ip&#x27;: f&#x27;192.168.56.&#123;i&#125;&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125; for i in</span></span><br><span class="line"><span class="comment">#              range(100, 130, 10)]</span></span><br><span class="line"><span class="comment"># print(data_list)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#x27;192.168.56.100&#x27;, &#x27;192.168.56.110&#x27;, &#x27;192.168.56.120&#x27;]</span></span><br><span class="line"><span class="string">[&#123;&#x27;ip&#x27;: &#x27;192.168.56.100&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125;, </span></span><br><span class="line"><span class="string">&#123;&#x27;ip&#x27;: &#x27;192.168.56.110&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125;, </span></span><br><span class="line"><span class="string">&#123;&#x27;ip&#x27;: &#x27;192.168.56.120&#x27;, &#x27;port&#x27;: 22, &#x27;username&#x27;: &#x27;python&#x27;, &#x27;password&#x27;: &#x27;Huawei@123&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data_list = [&#123;<span class="string">f&#x27;CE<span class="subst">&#123;i&#125;</span>&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">f&#x27;192.168.56.<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125; <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">             <span class="built_in">range</span>(<span class="number">101</span>, <span class="number">104</span>)]</span><br><span class="line"><span class="built_in">print</span>(data_list)</span><br><span class="line"></span><br><span class="line">num = <span class="number">101</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">    res = ssh_config(i[<span class="string">f&#x27;CE<span class="subst">&#123;num&#125;</span>&#x27;</span>][<span class="string">&#x27;ip&#x27;</span>], <span class="number">22</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;Huawei@123&#x27;</span>, <span class="string">&#x27;sftp.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"><span class="comment"># res = ssh_config(&#x27;192.168.56.101&#x27;, 22, &#x27;python&#x27;, &#x27;Huawei@123&#x27;, &#x27;sftp.txt&#x27;)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&#x27;CE101&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;192.168.56.101&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;CE102&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;192.168.56.102&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;CE103&#x27;</span>: &#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;192.168.56.103&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;&#125;]</span><br><span class="line"></span><br><span class="line">Warning: The initial password poses security risks.</span><br><span class="line">The password needs to be changed. Change now? [Y/N]:N</span><br><span class="line"></span><br><span class="line">Info: The <span class="built_in">max</span> number of VTY users <span class="keyword">is</span> <span class="number">5</span>, the number of current VTY users online <span class="keyword">is</span> <span class="number">1</span>, <span class="keyword">and</span> total number of terminal users online <span class="keyword">is</span> <span class="number">2.</span></span><br><span class="line">      The current login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">50.</span></span><br><span class="line">      The last login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">11</span>:07:07 <span class="keyword">from</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span> through SSH.</span><br><span class="line">&lt;CE1&gt;system-view im </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[CE1]sftp server enable</span><br><span class="line">Info: The SFTP server <span class="keyword">is</span> already started.</span><br><span class="line">[CE1]ssh user python service-<span class="built_in">type</span> stelnet sftp</span><br><span class="line">[CE1]ssh user python sftp-directory cfcard:</span><br><span class="line">[CE1]ssh authorization-<span class="built_in">type</span> default root</span><br><span class="line"></span><br><span class="line">Warning: The initial password poses security risks.</span><br><span class="line">The password needs to be changed. Change now? [Y/N]:N</span><br><span class="line"></span><br><span class="line">Info: The <span class="built_in">max</span> number of VTY users <span class="keyword">is</span> <span class="number">5</span>, the number of current VTY users online <span class="keyword">is</span> <span class="number">1</span>, <span class="keyword">and</span> total number of terminal users online <span class="keyword">is</span> <span class="number">2.</span></span><br><span class="line">      The current login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">57.</span></span><br><span class="line">      First login successfully.</span><br><span class="line">&lt;CE2&gt;system-view im </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[CE2]sftp server enable</span><br><span class="line">Info: Succeeded <span class="keyword">in</span> starting the SFTP server.</span><br><span class="line">[CE2]ssh user python service-<span class="built_in">type</span> stelnet sftp</span><br><span class="line">[CE2]ssh user python sftp-directory cfcard:</span><br><span class="line">[CE2]ssh authorization-<span class="built_in">type</span> default root</span><br><span class="line"></span><br><span class="line">Warning: The initial password poses security risks.</span><br><span class="line">The password needs to be changed. Change now? [Y/N]:N</span><br><span class="line"></span><br><span class="line">Info: The <span class="built_in">max</span> number of VTY users <span class="keyword">is</span> <span class="number">5</span>, the number of current VTY users online <span class="keyword">is</span> <span class="number">1</span>, <span class="keyword">and</span> total number of terminal users online <span class="keyword">is</span> <span class="number">2.</span></span><br><span class="line">      The current login time <span class="keyword">is</span> <span class="number">2023</span>-07-<span class="number">21</span> <span class="number">15</span>:<span class="number">57</span>:<span class="number">04.</span></span><br><span class="line">      First login successfully.</span><br><span class="line">&lt;CE3&gt;system-view im </span><br><span class="line">Enter system view, <span class="keyword">return</span> user view <span class="keyword">with</span> <span class="keyword">return</span> command.</span><br><span class="line">[CE3]sftp server enable</span><br><span class="line">Info: Succeeded <span class="keyword">in</span> starting the SFTP server.</span><br><span class="line">[CE3]ssh user python service-<span class="built_in">type</span> stelnet sftp</span><br><span class="line">[CE3]ssh user python sftp-directory cfcard:</span><br><span class="line">[CE3]ssh authorization-<span class="built_in">type</span> default root</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量下载ensp配置</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_connect</span>(<span class="params">ip, port, username, password</span>):</span><br><span class="line">    ssh_client = paramiko.SSHClient()</span><br><span class="line">    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh_client.connect(hostname=ip, port=port, username=username, password=password)</span><br><span class="line">    <span class="keyword">return</span> ssh_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_config</span>(<span class="params">ip, port, username, password, file</span>):</span><br><span class="line">    ssh_client = ssh_connect(ip, port, username, password)</span><br><span class="line">    vty = ssh_client.invoke_shell()</span><br><span class="line">    vty.send(<span class="string">&#x27;N\n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    vty.send(<span class="string">&#x27;system-view im \n&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            vty.send(i)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">ip, port, sysname, username, password</span>):</span><br><span class="line">    today = datetime.now()</span><br><span class="line">    time_now = today.strftime(<span class="string">&quot;%Y-%m-%d %H-%M-%S&quot;</span>)</span><br><span class="line">    path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;files&quot;</span>, time_now + <span class="string">f&quot;-<span class="subst">&#123;sysname&#125;</span>.cfg&quot;</span>)</span><br><span class="line">    tran = paramiko.Transport((ip, port))</span><br><span class="line">    tran.connect(username=username, password=password)</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(tran)</span><br><span class="line">    sftp.get(<span class="string">&#x27;/vrpcfg.cfg&#x27;</span>, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_list = [&#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">f&#x27;192.168.56.<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="string">&#x27;sysname&#x27;</span>: <span class="string">f&#x27;CE<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;Huawei@123&#x27;</span>&#125;</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>, <span class="number">104</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_list:</span><br><span class="line">    download(ip=i[<span class="string">&quot;ip&quot;</span>], port=<span class="number">22</span>, sysname=i[<span class="string">&quot;sysname&quot;</span>], username=i[<span class="string">&quot;username&quot;</span>], password=i[<span class="string">&quot;password&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 在使用paramiko进行ssh登录时，可能会存在网络或者设备故障的问题</span></span><br><span class="line"><span class="comment"># 2. 如何判断设备登录成功</span></span><br><span class="line"><span class="comment"># 3. 如何保证回显完毕</span></span><br><span class="line"><span class="comment"># 4. 如何判断进入了系统视图</span></span><br><span class="line"><span class="comment"># 5. 如何判断命令执行成功</span></span><br><span class="line"><span class="comment"># 6. 命令执行成功之后，如何判断正确的返回了用户视图</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip</span>):</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.ip&#125;</span> 连接失败&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetMarkError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get-mark-error&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSH</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.session = <span class="literal">None</span></span><br><span class="line">        self.vty = <span class="literal">None</span></span><br><span class="line">        self.login = <span class="literal">False</span></span><br><span class="line">        self.config = <span class="literal">False</span></span><br><span class="line">        self.old_mark = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        ssh_session = paramiko.SSHClient()</span><br><span class="line">        ssh_session.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh_session.connect(hostname=self.ip, port=self.port, username=self.username, password=self.password)</span><br><span class="line">        self.session = ssh_session</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_vty</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.vty = self.session.invoke_shell()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断抓取信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mark</span>(<span class="params">self, output: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 创建正则表达式对象</span></span><br><span class="line">        pat = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;.+?&gt;&#x27;</span>)</span><br><span class="line">        res = pat.findall(output)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> GetMarkError</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mark = self.old_mark = res[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span>(self.mark)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_device</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.transport()</span><br><span class="line">            self.open_vty()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;success login&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">raise</span> LoginError(self.ip)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        output = self.vty.recv(<span class="number">65535</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.get_mark(output)</span><br><span class="line">        self.login = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_result</span>(<span class="params">self, nbytes, interval=<span class="number">0.5</span></span>):</span><br><span class="line">        pat = re.<span class="built_in">compile</span>(self.mark)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res = self.vty.recv(nbytes).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            <span class="comment"># res += res</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pat.search(res):</span><br><span class="line">                time.sleep(interval)</span><br><span class="line">                self.vty.send(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        <span class="comment"># 新的表达式匹配方式</span></span><br><span class="line">        <span class="comment"># self.mark = &#x27;\[.+?\]&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.vty.send(command + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        res = self.recv_result(<span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># time.sleep(1)</span></span><br><span class="line">        <span class="comment"># return self.vty.recv(65535).decode(&#x27;utf-8&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">config_mode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.login:</span><br><span class="line">            self.login_device()</span><br><span class="line">        self.mark = <span class="string">&#x27;\[.+?\]&#x27;</span></span><br><span class="line">        self.test_command(<span class="string">&#x27;system-view&#x27;</span>)</span><br><span class="line">        self.config = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">self</span>):</span><br><span class="line">        self.mark = self.old_mark</span><br><span class="line">        <span class="keyword">return</span> self.test_command(<span class="string">&#x27;return&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params">self, command: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.config:</span><br><span class="line">            self.config_mode()</span><br><span class="line">        ret = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> command:</span><br><span class="line">            res = self.test_command(i)</span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            ret += res</span><br><span class="line">        ret += self.test_command(<span class="string">&#x27;commit&#x27;</span>)</span><br><span class="line">        ret += self.exit()</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ssh_client = SSH(ip=<span class="string">&#x27;192.168.56.102&#x27;</span>, port=<span class="number">22</span>, username=<span class="string">&#x27;python&#x27;</span>, password=<span class="string">&#x27;Cloud12#$&#x27;</span>)</span><br><span class="line">    <span class="comment"># res = ssh_client.login_device()</span></span><br><span class="line">    <span class="comment"># res = ssh_client.send_command(&#x27;dis cu&#x27;)</span></span><br><span class="line">    res = ssh_client.send_command([<span class="string">&quot;interface GE1/0/0&quot;</span>, <span class="string">&#x27;des cloud&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Datacom</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础</title>
    <url>/2023/10/18/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>摘要:   Python的Socket编程是指使用Python语言进行网络编程，使用的基础是Socket库。这个库提供了与底层操作系统套接字接口几乎相同的接口，使得Python开发者可以像使用C语言一样对网络数据流进行操作。</p>
<span id="more"></span>

<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="C-S架构与B-S架构"><a href="#C-S架构与B-S架构" class="headerlink" title="C&#x2F;S架构与B&#x2F;S架构"></a>C&#x2F;S架构与B&#x2F;S架构</h3><p>c&#x2F;s架构  client&#x2F;server<br>b&#x2F;s架构  browser（浏览器）&#x2F;server</p>
<p>web1.0 纯静态页面，不能交互html文档<br>web2.0 支持用户上传信息，交互，购物 网站后台：ruby java perl php python<br>web3.0 移动互联网时代 衣食住行 出门只带个手机 网站后台:java php python go</p>
<h3 id="半链接池"><a href="#半链接池" class="headerlink" title="半链接池"></a>半链接池</h3><p>假设同一时间有多个请求从客户端发送到服务端，服务端不会全部把这些请求加载到内存中，</p>
<p>而是会根据半链接池的容量将这些请求放在半链接池中。由于此时只是访问的请求，并不是一个完整的链接，因此叫做半链接。</p>
<p>因此如果遇到洪水攻击，需要减少半链接池的容量。</p>
<h2 id="Socket模块"><a href="#Socket模块" class="headerlink" title="Socket模块"></a>Socket模块</h2><h3 id="Socket（套接字）简介"><a href="#Socket（套接字）简介" class="headerlink" title="Socket（套接字）简介"></a>Socket（套接字）简介</h3><p>如果正常情况下，当我们开发了应用程序后，数据需要根据网络模型逐层完成封装才能发送出去。如果这些封装都由自己来完成，那么必须十分清楚每一层的协议的各个字段，并且很清晰的了解封装的方法才能最终将数据发送出去。</p>
<p>而在真实做程序开发时，可以理解为应用层与传输层之间，还夹杂了一层socket抽象层，也叫作套接字。</p>
<p>借助于该抽象层，我们在应用层产生的所有数据只要通过socket开放的接口丢给socket，那么socket就会自动的对该数据去完成封装。同时对于收到的数据，也可以解封装后交给应用程序。因此套接字封装的是传输层及以下</p>
<p>python当中也提供了socket模块</p>
<p>应用层产生数据，作为开发者，不需要关注每一层具体是如何完成封装的，而是直接讲数据丢给socket模块的接口，由socket逻辑抽象层自动的完成封装</p>
<h3 id="基于tcp协议的套接字通信"><a href="#基于tcp协议的套接字通信" class="headerlink" title="基于tcp协议的套接字通信"></a>基于tcp协议的套接字通信</h3><h4 id="基本通信"><a href="#基本通信" class="headerlink" title="基本通信"></a>基本通信</h4><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line">conn, client_addr = server.accept()</span><br><span class="line"><span class="comment"># 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line">data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># 7. 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息:&quot;</span>)</span><br><span class="line">client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># 4. 收信息</span></span><br><span class="line">res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<h4 id="通信循环"><a href="#通信循环" class="headerlink" title="通信循环"></a>通信循环</h4><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"></span><br><span class="line">conn, client_addr = server.accept()</span><br><span class="line">    <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">    <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">    conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># # 7. 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息(q/Q退出):&quot;</span>)</span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>



<h4 id="BUG修正"><a href="#BUG修正" class="headerlink" title="BUG修正"></a>BUG修正</h4><ol>
<li>当客户端发送给服务端的信息为空时,此时服务端会一直等待从自身的缓存当中拿到数据，因此程序会出现卡壳的现象</li>
</ol>
<p>tips:在进行网络编程时，客户调和服务端使用send和recv方法来发送和接收数据时，从基本角度来说并不是跟对方打交道，而是跟自身的缓存打交道</p>
<ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"></span><br><span class="line">conn, client_addr = server.accept()</span><br><span class="line">    <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">    <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">    conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># # 7. 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>如果客户端断开连接，此时服务端会卡在接收信息的地方</li>
</ul>
<p>server</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;客户端发来的信息为%s&quot;</span>%data)</span><br><span class="line">        <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">break</span>   <span class="comment">#通过这一步来解决客户端意外断开连接的情况</span></span><br><span class="line">        <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br></pre></td></tr></table></figure>



<h4 id="链接循环"><a href="#链接循环" class="headerlink" title="链接循环"></a>链接循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="验证半链接池"><a href="#验证半链接池" class="headerlink" title="验证半链接池"></a>验证半链接池</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> data.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> data.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(data.upper().encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转换的信息(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>



<h3 id="基于udp协议的套接字通信"><a href="#基于udp协议的套接字通信" class="headerlink" title="基于udp协议的套接字通信"></a>基于udp协议的套接字通信</h3><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个基于UDP套接字通信的服务端</span></span><br><span class="line">server = socket(AF_INET, SOCK_DGRAM) </span><br><span class="line"><span class="comment"># 服务端绑定IP和端口信息</span></span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 设定最大接收字节数，recvfrom返回值是一个元组，分别是接收到的数据和客户端的ip以及端口信息</span></span><br><span class="line">data_info,client_addr = server.recvfrom(<span class="number">1024</span>)</span><br><span class="line">res = data_info.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">result = res+res</span><br><span class="line"><span class="built_in">print</span>(client_addr)</span><br><span class="line"><span class="comment"># 发送数据，同时需要指定客户端的ip和端口信息</span></span><br><span class="line">server.sendto(result.encode(<span class="string">&quot;utf-8&quot;</span>),client_addr)</span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个基于UDP套接字通信的客户端</span></span><br><span class="line">client = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入一段内容:&quot;</span>).strip()</span><br><span class="line"><span class="comment"># 发送数据，同时需要指定服务端的ip和端口信息</span></span><br><span class="line">client.sendto(user_input.encode(<span class="string">&quot;utf-8&quot;</span>),(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 设定接收最大字节数，recvfrom返回的是数据+服务端ip和端口的信息</span></span><br><span class="line">res, server_addr= client.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(res.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><h3 id="什么是粘包？"><a href="#什么是粘包？" class="headerlink" title="什么是粘包？"></a>什么是粘包？</h3><ul>
<li>补充subprocess模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">    obj = subprocess.Popen(args=cmd,</span><br><span class="line">                           shell=<span class="literal">True</span>,</span><br><span class="line">                           stdout=subprocess.PIPE,</span><br><span class="line">                           stderr=subprocess.PIPE</span><br><span class="line">    )</span><br><span class="line">    std_out = obj.stdout.read()</span><br><span class="line">    std_err = obj.stderr.read()</span><br><span class="line">    result = (std_out+std_err).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>



<p>对于TCP协议而言，recv和send本质上都是与自身的缓存打交道，send就是将缓存当中的数据发送出去，而recv就是根据设置的接收最大字节数从缓存中取出该长度的数据</p>
<p>在执行不同的命令时，所得到的回显结果是没有边界感的，所有的数据都粘在一起，这就是TCP的粘包现象</p>
<ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        obj = subprocess.Popen(args=cmd,</span><br><span class="line">                               shell=<span class="literal">True</span>,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE</span><br><span class="line">                               )</span><br><span class="line">        std_out = obj.stdout.read()</span><br><span class="line">        std_err = obj.stderr.read()</span><br><span class="line">        result = std_out + std_err</span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    res = client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="如何解决粘包"><a href="#如何解决粘包" class="headerlink" title="如何解决粘包"></a>如何解决粘包</h3><ul>
<li>server</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.买服务器</span></span><br><span class="line"><span class="comment"># AF_INET 标识了socket的地址族，是用于网络传输的</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 标识协议的类型，而TCP协议是一种典型的流式协议</span></span><br><span class="line"><span class="comment"># 此时的server就定义了一个用于网络传输，并且采用TCP协议的服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2.绑定网卡</span></span><br><span class="line">server.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3.开机</span></span><br><span class="line"><span class="comment"># listen标识了半连接池的容量，此时最多可以容纳5个连接请求</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 4.监听连接请求</span></span><br><span class="line"><span class="comment"># (1) 从半连接池当中取出一个链接请求交给accept处理，建立链接</span></span><br><span class="line"><span class="comment"># (2) accept处理完链接请求得到的返回值为一个元组，分别代表真实</span></span><br><span class="line"><span class="comment">#     建成的连接，以及该连接中客户端具体的IP地址信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_addr = server.accept()</span><br><span class="line">        <span class="comment"># # 5. 接受信息，recv表示每次最多接收多少个字节的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd.__len__() == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cmd.upper() == <span class="string">&quot;Q&quot;</span>:<span class="keyword">break</span></span><br><span class="line">        obj = subprocess.Popen(args=cmd,</span><br><span class="line">                               shell=<span class="literal">True</span>,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE</span><br><span class="line">                               )</span><br><span class="line">        std_out = obj.stdout.read()</span><br><span class="line">        std_err = obj.stderr.read()</span><br><span class="line">        result = std_out + std_err</span><br><span class="line">        total_size = struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(result))</span><br><span class="line">        <span class="comment"># # 6. 发送消息，使用send方法，只能发从字节类型的数据</span></span><br><span class="line">        conn.send(total_size)</span><br><span class="line">        conn.send(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 7. 关闭连接</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="comment"># # # 8. 关闭服务器</span></span><br><span class="line"><span class="comment"># # server.close()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 产生一个客户端</span></span><br><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 2. 发起连接请求</span></span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 3. 发信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入需要执行的命令(q/Q退出):&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> user_input.__len__() == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">    client.send(user_input.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> user_input.upper() == <span class="string">&quot;Q&quot;</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 4. 收信息</span></span><br><span class="line">    total_size = struct.unpack(<span class="string">&#x27;i&#x27;</span>, client.recv(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> size &lt; total_size:</span><br><span class="line">        res += client.recv(<span class="number">1024</span>).decode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">        size += <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 关闭客户端</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
